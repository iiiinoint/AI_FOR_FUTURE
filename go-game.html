<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›´æ£‹ - äººæœºå¯¹æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #go-board {
            position: relative;
            background: linear-gradient(135deg, #DCB35C 0%, #C49A3C 100%);
            box-shadow:
                inset 0 0 30px rgba(0, 0, 0, 0.2),
                0 10px 30px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
        }

        .grid-line {
            position: absolute;
            background: #000;
        }

        .grid-line.horizontal {
            height: 1px;
            left: 20px;
            right: 20px;
        }

        .grid-line.vertical {
            width: 1px;
            top: 20px;
            bottom: 20px;
        }

        .star-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .stone {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s ease;
            cursor: default;
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #000);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #ff4444;
            border-radius: 50%;
        }

        .stone.last-move.white::after {
            background: #ff0000;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        #pass-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        #restart-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        #undo-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        #home-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            font-size: 18px;
            color: #333;
            min-height: 27px;
        }

        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-content h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #333;
        }

        .result-details {
            margin: 20px 0;
            font-size: 1.2em;
            color: #666;
        }

        .winner {
            font-size: 2.5em;
            font-weight: bold;
            margin: 20px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            #game-container {
                padding: 15px;
            }

            .game-info {
                flex-wrap: wrap;
                gap: 10px;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }
        }

        /* éš¾åº¦é€‰æ‹©ç•Œé¢ */
        #difficulty-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #difficulty-modal.hidden {
            display: none;
        }

        .difficulty-content {
            background: white;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalFadeIn 0.3s ease;
            max-width: 500px;
            width: 90%;
        }

        .difficulty-content h2 {
            font-size: 2.5em;
            margin-bottom: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .difficulty-btn {
            padding: 20px 40px;
            font-size: 20px;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .difficulty-btn:hover::before {
            left: 100%;
        }

        .difficulty-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #333;
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .difficulty-description {
            margin-top: 8px;
            font-size: 14px;
            opacity: 0.8;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <!-- éš¾åº¦é€‰æ‹©ç•Œé¢ -->
    <div id="difficulty-modal">
        <div class="difficulty-content">
            <h2>é€‰æ‹©éš¾åº¦</h2>
            <div class="difficulty-buttons">
                <button class="difficulty-btn easy" onclick="startGame('easy')">
                    ğŸ˜Š ç®€å•
                    <div class="difficulty-description">éšæœºè½å­ï¼Œé€‚åˆåˆå­¦è€…</div>
                </button>
                <button class="difficulty-btn medium" onclick="startGame('medium')">
                    ğŸ¤” ä¸­ç­‰
                    <div class="difficulty-description">ä¼šæå­å’Œé˜²å®ˆï¼Œæœ‰åŸºæœ¬ç­–ç•¥</div>
                </button>
                <button class="difficulty-btn hard" onclick="startGame('hard')">
                    ğŸ˜ˆ å›°éš¾
                    <div class="difficulty-description">é«˜çº§ç­–ç•¥ï¼Œå–„äºåˆ‡æ–­å’Œå›´åœ°</div>
                </button>
            </div>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <h1>å›´æ£‹ äººæœºå¯¹æˆ˜</h1>

        <div class="game-info">
            <div class="info-item">
                <div class="info-label">å½“å‰å›åˆ</div>
                <div class="info-value" id="current-player">é»‘æ–¹ (ç©å®¶)</div>
            </div>
            <div class="info-item">
                <div class="info-label">é»‘æ–¹æå­</div>
                <div class="info-value" id="black-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">ç™½æ–¹æå­</div>
                <div class="info-value" id="white-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">æ‰‹æ•°</div>
                <div class="info-value" id="move-count">0</div>
            </div>
        </div>

        <div class="board-container">
            <div id="go-board"></div>
        </div>

        <div class="controls">
            <button id="pass-btn">åœç€</button>
            <button id="undo-btn">æ‚”æ£‹</button>
            <button id="restart-btn">é‡æ–°å¼€å§‹</button>
            <button id="home-btn">è¿”å›ä¸»é¡µ</button>
        </div>

        <div class="status" id="status">ç‚¹å‡»æ£‹ç›˜è½å­ï¼Œé»‘æ–¹å…ˆè¡Œ</div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <div class="winner" id="winner"></div>
            <div class="result-details" id="result-details"></div>
            <div class="modal-buttons">
                <button class="modal-btn" id="modal-restart">å†æ¥ä¸€å±€</button>
                <button class="modal-btn" id="modal-home">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== å¸¸é‡å®šä¹‰ ====================
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        // ==================== GoBoard ç±» ====================
        class GoBoard {
            constructor(size = 13) {
                this.size = size;
                this.grid = Array(size).fill(null).map(() => Array(size).fill(EMPTY));
                this.koPoint = null;
                this.history = [];
                this.captures = { black: 0, white: 0 };
                this.lastMove = null;
            }

            // å¤åˆ¶æ£‹ç›˜
            clone() {
                const newBoard = new GoBoard(this.size);
                newBoard.grid = this.grid.map(row => [...row]);
                newBoard.koPoint = this.koPoint ? { ...this.koPoint } : null;
                newBoard.history = [...this.history];
                newBoard.captures = { ...this.captures };
                newBoard.lastMove = this.lastMove ? { ...this.lastMove } : null;
                return newBoard;
            }

            // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨æ£‹ç›˜å†…
            isOnBoard(x, y) {
                return x >= 0 && x < this.size && y >= 0 && y < this.size;
            }

            // è·å–æ£‹å­ç»„ï¼ˆæ³›æ´ªç®—æ³•ï¼‰
            getGroup(startX, startY) {
                const color = this.grid[startY][startX];
                if (color === EMPTY) return [];

                const group = [];
                const visited = new Set();
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (this.grid[y][x] === color) {
                        group.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];

                        neighbors.forEach(n => {
                            if (this.isOnBoard(n.x, n.y) && !visited.has(`${n.x},${n.y}`)) {
                                stack.push(n);
                            }
                        });
                    }
                }

                return group;
            }

            // è®¡ç®—æ°”æ•°
            getLiberties(group) {
                const liberties = new Set();

                group.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === EMPTY) {
                            liberties.add(`${n.x},${n.y}`);
                        }
                    });
                });

                return liberties.size;
            }

            // æ£€æµ‹æå­
            detectCaptures(x, y, placedColor) {
                const opponentColor = placedColor === BLACK ? WHITE : BLACK;
                const captured = [];

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                neighbors.forEach(n => {
                    if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === opponentColor) {
                        const group = this.getGroup(n.x, n.y);
                        const liberties = this.getLiberties(group);

                        if (liberties === 0) {
                            group.forEach(stone => {
                                if (!captured.some(c => c.x === stone.x && c.y === stone.y)) {
                                    captured.push(stone);
                                }
                            });
                        }
                    }
                });

                return captured;
            }

            // ç§»é™¤æ£‹å­ç»„
            removeGroup(group) {
                group.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });
            }

            // è·å–æ£‹ç›˜å“ˆå¸Œå€¼ï¼ˆç”¨äºæ‰“åŠ«æ£€æµ‹ï¼‰
            getBoardHash() {
                return this.grid.map(row => row.join('')).join('|');
            }

            // è½å­
            placeStone(x, y, color) {
                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    return false;
                }

                // æ”¾ç½®æ£‹å­
                this.grid[y][x] = color;

                // æ£€æŸ¥æå­ï¼ˆåœ¨è½å­åï¼‰
                const captured = this.detectCaptures(x, y, color);

                // æ£€æŸ¥è‡ªæ€ï¼ˆå¦‚æœæ²¡æœ‰æå­ä¸”è‡ªå·±ä¹Ÿæ²¡æ°”äº†ï¼‰
                if (captured.length === 0) {
                    const group = this.getGroup(x, y);
                    const liberties = this.getLiberties(group);
                    if (liberties === 0) {
                        // æ’¤é”€è½å­
                        this.grid[y][x] = EMPTY;
                        return false;
                    }
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    // æ’¤é”€è½å­å’Œæå­
                    this.grid[y][x] = EMPTY;
                    captured.forEach(stone => {
                        this.grid[stone.y][stone.x] = (color === BLACK ? WHITE : BLACK);
                    });
                    return false;
                }

                // ç§»é™¤è¢«æçš„å­
                captured.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });

                // æ›´æ–°æå­æ•°
                if (color === BLACK) {
                    this.captures.black += captured.length;
                } else {
                    this.captures.white += captured.length;
                }

                // æ›´æ–°æ‰“åŠ«ç‚¹
                if (captured.length === 1) {
                    const opponentsGroups = [];
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === (color === BLACK ? WHITE : BLACK)) {
                            opponentsGroups.push(this.getGroup(n.x, n.y));
                        }
                    });

                    const ownGroup = this.getGroup(x, y);
                    if (ownGroup.length === 1 && this.getLiberties(ownGroup) === 1 && opponentsGroups.some(g => g.length === 1)) {
                        this.koPoint = captured[0];
                    } else {
                        this.koPoint = null;
                    }
                } else {
                    this.koPoint = null;
                }

                // è®°å½•å†å²
                this.history.push({
                    x, y, color,
                    captures: captured,
                    boardHash: this.getBoardHash()
                });

                this.lastMove = { x, y };

                return true;
            }

            // éªŒè¯è½å­æ˜¯å¦åˆæ³•
            isValidMove(x, y, color) {
                // æ£€æŸ¥ä½ç½®æ˜¯å¦ä¸ºç©º
                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    return false;
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    return false;
                }

                // æ£€æŸ¥è‡ªæ€
                const tempBoard = this.clone();
                tempBoard.grid[y][x] = color;
                const captures = tempBoard.detectCaptures(x, y, color);

                if (captures.length === 0) {
                    const group = tempBoard.getGroup(x, y);
                    const liberties = tempBoard.getLiberties(group);
                    if (liberties === 0) {
                        return false;
                    }
                }

                return true;
            }

            // æ•°åœ°
            countTerritory() {
                const territory = { black: 0, white: 0 };
                const visited = new Set();

                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const key = `${x},${y}`;
                        if (this.grid[y][x] === EMPTY && !visited.has(key)) {
                            const region = this.getEmptyRegion(x, y, visited);
                            const owner = this.determineTerritoryOwner(region);

                            if (owner === BLACK) {
                                territory.black += region.length;
                            } else if (owner === WHITE) {
                                territory.white += region.length;
                            }
                        }
                    }
                }

                return territory;
            }

            // è·å–ç©ºåœ°åŒºåŸŸ
            getEmptyRegion(startX, startY, visited) {
                const region = [];
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key) || !this.isOnBoard(x, y)) continue;

                    if (this.grid[y][x] === EMPTY) {
                        visited.add(key);
                        region.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];
                        neighbors.forEach(n => stack.push(n));
                    }
                }

                return region;
            }

            // åˆ¤æ–­åœ°åŸŸå½’å±
            determineTerritoryOwner(region) {
                const surroundingColors = new Set();

                region.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] !== EMPTY) {
                            surroundingColors.add(this.grid[n.y][n.x]);
                        }
                    });
                });

                if (surroundingColors.size === 1) {
                    return surroundingColors.values().next().value;
                }

                return null;
            }

            // æ’¤é”€ä¸Šä¸€æ­¥
            undo() {
                if (this.history.length === 0) return false;

                const lastMove = this.history.pop();

                // æ¢å¤æ£‹ç›˜çŠ¶æ€
                this.grid[lastMove.y][lastMove.x] = EMPTY;

                // æ¢å¤è¢«æçš„å­
                const opponentColor = lastMove.color === BLACK ? WHITE : BLACK;
                lastMove.captures.forEach(stone => {
                    this.grid[stone.y][stone.x] = opponentColor;
                });

                // æ›´æ–°æå­æ•°
                if (lastMove.color === BLACK) {
                    this.captures.black -= lastMove.captures.length;
                } else {
                    this.captures.white -= lastMove.captures.length;
                }

                // æ›´æ–°æœ€åè½å­ä½ç½®
                this.lastMove = this.history.length > 0 ? {
                    x: this.history[this.history.length - 1].x,
                    y: this.history[this.history.length - 1].y
                } : null;

                return true;
            }
        }

        // ==================== GoAI ç±» ====================
        class GoAI {
            constructor(color, board, difficulty = 'medium') {
                this.color = color;
                this.board = board;
                this.difficulty = difficulty;
            }

            // é€‰æ‹©è½å­ï¼ˆæ ¹æ®éš¾åº¦ï¼‰
            selectMove() {
                switch (this.difficulty) {
                    case 'easy':
                        return this.selectMoveEasy();
                    case 'medium':
                        return this.selectMoveMedium();
                    case 'hard':
                        return this.selectMoveHard();
                    default:
                        return this.selectMoveMedium();
                }
            }

            // ==================== ç®€å•éš¾åº¦ ====================
            selectMoveEasy() {
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            // ç®€å•AIï¼šåªè€ƒè™‘æœ‰ç›¸é‚»æ£‹å­æˆ–æ˜Ÿä½çš„ä½ç½®
                            if (this.hasNeighborStone(x, y) || this.isStarPoint(x, y)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }

                if (candidates.length === 0) {
                    // å¦‚æœæ²¡æœ‰å€™é€‰ç‚¹ï¼Œéšæœºé€‰æ‹©ç©ºä½
                    for (let y = 0; y < this.board.size; y++) {
                        for (let x = 0; x < this.board.size; x++) {
                            if (this.board.grid[y][x] === EMPTY) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }

                if (candidates.length > 0) {
                    const randomIndex = Math.floor(Math.random() * candidates.length);
                    return candidates[randomIndex];
                }

                return null;
            }

            // ==================== ä¸­ç­‰éš¾åº¦ ====================
            selectMoveMedium() {
                // ä¼˜å…ˆçº§1: å¯»æ‰¾æå­æœºä¼š
                const captureMoves = this.findCaptureMoves();
                if (captureMoves.length > 0) {
                    return captureMoves[0];
                }

                // ä¼˜å…ˆçº§2: å¯»æ‰¾é˜²å®ˆæœºä¼š
                const defenseMoves = this.findDefenseMoves();
                if (defenseMoves.length > 0) {
                    return defenseMoves[0];
                }

                // ä¼˜å…ˆçº§3: ä½ç½®è¯„ä¼°
                const candidates = this.getCandidateMoves();
                if (candidates.length > 0) {
                    return this.evaluateAndSelectBest(candidates);
                }

                return null;
            }

            // ==================== å›°éš¾éš¾åº¦ ====================
            selectMoveHard() {
                // ä¼˜å…ˆçº§1: å¯»æ‰¾æå­æœºä¼šï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰
                const captureMoves = this.findCaptureMoves();
                if (captureMoves.length > 0) {
                    return captureMoves[0];
                }

                // ä¼˜å…ˆçº§2: å¯»æ‰¾åˆ‡æ–­æœºä¼šï¼ˆæ–°å¢ï¼‰
                const cutMoves = this.findCutMoves();
                if (cutMoves.length > 0) {
                    return cutMoves[0];
                }

                // ä¼˜å…ˆçº§3: å¯»æ‰¾é˜²å®ˆæœºä¼š
                const defenseMoves = this.findDefenseMoves();
                if (defenseMoves.length > 0) {
                    return defenseMoves[0];
                }

                // ä¼˜å…ˆçº§4: å¯»æ‰¾è¿›æ”»æœºä¼šï¼ˆå«åƒï¼‰
                const atariMoves = this.findAtariMoves();
                if (atariMoves.length > 0) {
                    return atariMoves[0];
                }

                // ä¼˜å…ˆçº§5: é«˜çº§ä½ç½®è¯„ä¼°
                const candidates = this.getCandidateMoves();
                if (candidates.length > 0) {
                    return this.evaluateAndSelectBestAdvanced(candidates);
                }

                return null;
            }

            // å¯»æ‰¾æå­æœºä¼š
            findCaptureMoves() {
                const moves = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.isOnBoard(x, y) && this.board.grid[y][x] === EMPTY) {
                            const tempBoard = this.board.clone();
                            if (tempBoard.placeStone(x, y, this.color)) {
                                const captures = tempBoard.detectCaptures(x, y, this.color);
                                if (captures.length > 0) {
                                    moves.push({ x, y, priority: captures.length });
                                }
                            }
                        }
                    }
                }

                return moves.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾é˜²å®ˆæœºä¼š
            findDefenseMoves() {
                const defenses = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === this.color) {
                            const group = this.board.getGroup(x, y);
                            const liberties = this.board.getLiberties(group);

                            if (liberties === 1) {
                                group.forEach(stone => {
                                    const neighbors = [
                                        { x: stone.x - 1, y: stone.y },
                                        { x: stone.x + 1, y: stone.y },
                                        { x: stone.x, y: stone.y - 1 },
                                        { x: stone.x, y: stone.y + 1 }
                                    ];

                                    neighbors.forEach(n => {
                                        if (this.board.isOnBoard(n.x, n.y) &&
                                            this.board.grid[n.y][n.x] === EMPTY) {
                                            if (!defenses.some(d => d.x === n.x && d.y === n.y)) {
                                                defenses.push({ x: n.x, y: n.y, priority: 10 });
                                            }
                                        }
                                    });
                                });
                            }
                        }
                    }
                }

                return defenses.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾åˆ‡æ–­æœºä¼šï¼ˆå›°éš¾æ¨¡å¼æ–°å¢ï¼‰
            findCutMoves() {
                const cuts = [];
                const opponentColor = this.color === BLACK ? WHITE : BLACK;

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            // æ£€æŸ¥è½å­åæ˜¯å¦èƒ½åˆ‡æ–­å¯¹æ–¹
                            const neighbors = [
                                { x: x - 1, y }, { x: x + 1, y },
                                { x, y: y - 1 }, { x, y: y + 1 }
                            ];

                            const opponentNeighbors = neighbors.filter(n =>
                                this.board.isOnBoard(n.x, n.y) &&
                                this.board.grid[n.y][n.x] === opponentColor
                            );

                            if (opponentNeighbors.length >= 2) {
                                // æ£€æŸ¥è¿™äº›å¯¹æ–¹æ£‹å­æ˜¯å¦å±äºä¸åŒç»„
                                const groups = opponentNeighbors.map(n => this.board.getGroup(n.x, n.y));
                                const uniqueGroups = [];
                                groups.forEach(g => {
                                    if (!uniqueGroups.some(ug => ug[0].x === g[0].x && ug[0].y === g[0].y)) {
                                        uniqueGroups.push(g);
                                    }
                                });

                                if (uniqueGroups.length >= 2) {
                                    cuts.push({ x, y, priority: uniqueGroups.length });
                                }
                            }
                        }
                    }
                }

                return cuts.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾å«åƒæœºä¼šï¼ˆå›°éš¾æ¨¡å¼æ–°å¢ï¼‰
            findAtariMoves() {
                const ataris = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            const tempBoard = this.board.clone();
                            if (tempBoard.placeStone(x, y, this.color)) {
                                const opponentColor = this.color === BLACK ? WHITE : BLACK;
                                const neighbors = [
                                    { x: x - 1, y }, { x: x + 1, y },
                                    { x, y: y - 1 }, { x, y: y + 1 }
                                ];

                                neighbors.forEach(n => {
                                    if (tempBoard.isOnBoard(n.x, n.y) &&
                                        tempBoard.grid[n.y][n.x] === opponentColor) {
                                        const group = tempBoard.getGroup(n.x, n.y);
                                        const liberties = tempBoard.getLiberties(group);

                                        if (liberties === 1) {
                                            if (!ataris.some(a => a.x === x && a.y === y)) {
                                                ataris.push({ x, y, priority: group.length });
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                return ataris.sort((a, b) => b.priority - a.priority);
            }

            // è·å–å€™é€‰è½å­ç‚¹
            getCandidateMoves() {
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            const hasNeighbor = this.hasNeighborStone(x, y);
                            if (hasNeighbor || this.isStarPoint(x, y)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }

                return candidates;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸é‚»æ£‹å­
            hasNeighborStone(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                return neighbors.some(n =>
                    this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] !== EMPTY
                );
            }

            // åˆ¤æ–­æ˜¯å¦ä¸ºæ˜Ÿä½
            isStarPoint(x, y) {
                const size = this.board.size;
                const starPoints = size === 13 ?
                    [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]] :
                    size === 19 ?
                    [[3, 3], [9, 3], [15, 3], [3, 9], [9, 9], [15, 9], [3, 15], [9, 15], [15, 15]] :
                    [];

                return starPoints.some(p => p[0] === x && p[1] === y);
            }

            // åŸºç¡€è¯„ä¼°ï¼ˆä¸­ç­‰éš¾åº¦ï¼‰
            evaluateAndSelectBest(candidates) {
                if (candidates.length === 0) return null;

                const scored = candidates.map(move => {
                    let score = 0;

                    const center = Math.floor(this.board.size / 2);
                    const distFromCenter = Math.abs(move.x - center) + Math.abs(move.y - center);
                    score += (this.board.size - distFromCenter);

                    if (this.isStarPoint(move.x, move.y)) {
                        score += 5;
                    }

                    if (this.hasNeighborStone(move.x, move.y)) {
                        score += 3;
                    }

                    score += Math.random() * 3;

                    return { ...move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                return scored[0];
            }

            // é«˜çº§è¯„ä¼°ï¼ˆå›°éš¾éš¾åº¦ï¼‰
            evaluateAndSelectBestAdvanced(candidates) {
                if (candidates.length === 0) return null;

                const scored = candidates.map(move => {
                    let score = 0;

                    // ä¸­å¿ƒä½ç½®åŠ åˆ†
                    const center = Math.floor(this.board.size / 2);
                    const distFromCenter = Math.abs(move.x - center) + Math.abs(move.y - center);
                    score += (this.board.size - distFromCenter) * 1.5;

                    // æ˜Ÿä½åŠ åˆ†æ›´é«˜
                    if (this.isStarPoint(move.x, move.y)) {
                        score += 8;
                    }

                    // ç›¸é‚»æ£‹å­åŠ åˆ†
                    if (this.hasNeighborStone(move.x, move.y)) {
                        const neighborCount = this.countNeighborStones(move.x, move.y);
                        score += neighborCount * 4;

                        // æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥è‡ªå·±çš„æ£‹å­
                        if (this.canConnectOwnStones(move.x, move.y)) {
                            score += 6;
                        }
                    }

                    // è¾¹ç¼˜ä½ç½®å‡åˆ†ï¼ˆé¿å…ä¸€è·¯ï¼‰
                    if (move.x === 0 || move.x === this.board.size - 1 ||
                        move.y === 0 || move.y === this.board.size - 1) {
                        score -= 3;
                    }

                    // äºŒè·¯ä½ç½®è½»å¾®å‡åˆ†
                    if (move.x === 1 || move.x === this.board.size - 2 ||
                        move.y === 1 || move.y === this.board.size - 2) {
                        score -= 1;
                    }

                    // æ·»åŠ å°‘é‡éšæœºæ€§
                    score += Math.random() * 2;

                    return { ...move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                return scored[0];
            }

            // è®¡ç®—ç›¸é‚»æ£‹å­æ•°é‡
            countNeighborStones(x, y) {
                let count = 0;
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                neighbors.forEach(n => {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] !== EMPTY) {
                        count++;
                    }
                });

                return count;
            }

            // æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥è‡ªå·±çš„æ£‹å­
            canConnectOwnStones(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                let ownCount = 0;
                neighbors.forEach(n => {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] === this.color) {
                        ownCount++;
                    }
                });

                return ownCount >= 2;
            }
        }

        // ==================== UIController ç±» ====================
        class UIController {
            constructor() {
                this.boardElement = document.getElementById('go-board');
                this.infoElements = {
                    currentPlayer: document.getElementById('current-player'),
                    blackCaptures: document.getElementById('black-captures'),
                    whiteCaptures: document.getElementById('white-captures'),
                    moveCount: document.getElementById('move-count'),
                    status: document.getElementById('status')
                };
                this.modal = document.getElementById('modal');
                this.modalElements = {
                    winner: document.getElementById('winner'),
                    details: document.getElementById('result-details')
                };

                this.cellSize = 45;
                this.padding = 20;

                this.initBoard();
            }

            // åˆå§‹åŒ–æ£‹ç›˜
            initBoard() {
                const boardSize = this.cellSize * (13 - 1) + this.padding * 2;
                this.boardElement.style.width = boardSize + 'px';
                this.boardElement.style.height = boardSize + 'px';
                this.boardElement.innerHTML = '';

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                for (let i = 0; i < 13; i++) {
                    const pos = this.padding + i * this.cellSize;

                    // æ°´å¹³çº¿
                    const hLine = document.createElement('div');
                    hLine.className = 'grid-line horizontal';
                    hLine.style.top = pos + 'px';
                    this.boardElement.appendChild(hLine);

                    // å‚ç›´çº¿
                    const vLine = document.createElement('div');
                    vLine.className = 'grid-line vertical';
                    vLine.style.left = pos + 'px';
                    this.boardElement.appendChild(vLine);
                }

                // ç»˜åˆ¶æ˜Ÿä½
                const starPoints = [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]];
                starPoints.forEach(([x, y]) => {
                    const star = document.createElement('div');
                    star.className = 'star-point';
                    star.style.left = (this.padding + x * this.cellSize) + 'px';
                    star.style.top = (this.padding + y * this.cellSize) + 'px';
                    this.boardElement.appendChild(star);
                });
            }

            // æ¸²æŸ“æ£‹ç›˜
            renderBoard(board) {
                // æ¸…é™¤æ‰€æœ‰æ£‹å­
                const existingStones = this.boardElement.querySelectorAll('.stone');
                existingStones.forEach(stone => stone.remove());

                // ç»˜åˆ¶æ‰€æœ‰æ£‹å­
                for (let y = 0; y < board.size; y++) {
                    for (let x = 0; x < board.size; x++) {
                        if (board.grid[y][x] !== EMPTY) {
                            this.createStoneElement(x, y, board.grid[y][x], false);
                        }
                    }
                }

                // æ ‡è®°æœ€åè½å­
                if (board.lastMove) {
                    const lastStone = this.getStoneAt(board.lastMove.x, board.lastMove.y);
                    if (lastStone) {
                        lastStone.classList.add('last-move');
                    }
                }
            }

            // åˆ›å»ºæ£‹å­å…ƒç´ 
            createStoneElement(x, y, color, isLastMove = false) {
                const stone = document.createElement('div');
                stone.className = `stone ${color === BLACK ? 'black' : 'white'}`;
                stone.style.left = (this.padding + x * this.cellSize) + 'px';
                stone.style.top = (this.padding + y * this.cellSize) + 'px';
                stone.style.width = (this.cellSize - 4) + 'px';
                stone.style.height = (this.cellSize - 4) + 'px';
                stone.dataset.x = x;
                stone.dataset.y = y;

                if (isLastMove) {
                    stone.classList.add('last-move');
                }

                this.boardElement.appendChild(stone);
                return stone;
            }

            // è·å–æŒ‡å®šä½ç½®çš„æ£‹å­å…ƒç´ 
            getStoneAt(x, y) {
                return this.boardElement.querySelector(`.stone[data-x="${x}"][data-y="${y}"]`);
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatus(board, currentPlayer) {
                this.infoElements.currentPlayer.textContent =
                    currentPlayer === BLACK ? 'é»‘æ–¹ (ç©å®¶)' : 'ç™½æ–¹ (AI)';
                this.infoElements.blackCaptures.textContent = board.captures.black;
                this.infoElements.whiteCaptures.textContent = board.captures.white;
                this.infoElements.moveCount.textContent = board.history.length;
            }

            // æ˜¾ç¤ºæ¶ˆæ¯
            showMessage(message) {
                this.infoElements.status.textContent = message;
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
            showGameOver(result) {
                const winnerText = result.winner === BLACK ? 'é»‘æ–¹è·èƒœï¼' : 'ç™½æ–¹è·èƒœï¼';
                this.modalElements.winner.textContent = winnerText;

                const details = `
                    é»‘æ–¹: ${result.blackScore} ç‚¹ (æå­ ${result.captures.black})<br>
                    ç™½æ–¹: ${result.whiteScore} ç‚¹ (æå­ ${result.captures.white})
                `;
                this.modalElements.details.innerHTML = details;

                this.modal.classList.add('active');
            }

            // éšè—æ¨¡æ€æ¡†
            hideModal() {
                this.modal.classList.remove('active');
            }

            // è·å–ç‚¹å‡»åæ ‡
            getClickPosition(event) {
                const rect = this.boardElement.getBoundingClientRect();
                const x = Math.round((event.clientX - rect.left - this.padding) / this.cellSize);
                const y = Math.round((event.clientY - rect.top - this.padding) / this.cellSize);

                // ç¡®ä¿åæ ‡åœ¨æ£‹ç›˜èŒƒå›´å†… (0-12)
                return {
                    x: Math.max(0, Math.min(12, x)),
                    y: Math.max(0, Math.min(12, y))
                };
            }
        }

        // ==================== GameController ç±» ====================
        class GameController {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, difficulty);
                this.ui = new UIController();
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';
                this.passCount = 0;

                this.setupEventListeners();
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            getDifficultyName() {
                const names = {
                    'easy': 'ç®€å• ğŸ˜Š',
                    'medium': 'ä¸­ç­‰ ğŸ¤”',
                    'hard': 'å›°éš¾ ğŸ˜ˆ'
                };
                return names[this.difficulty] || this.difficulty;
            }

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners() {
                this.ui.boardElement.addEventListener('click', (e) => this.handleBoardClick(e));

                document.getElementById('pass-btn').addEventListener('click', () => this.handlePass());
                document.getElementById('restart-btn').addEventListener('click', () => this.restart());
                document.getElementById('undo-btn').addEventListener('click', () => this.handleUndo());
                document.getElementById('home-btn').addEventListener('click', () => this.backToDifficultySelect());
                document.getElementById('modal-restart').addEventListener('click', () => {
                    this.ui.hideModal();
                    this.restart();
                });
                document.getElementById('modal-home').addEventListener('click', () => {
                    this.ui.hideModal();
                    this.backToDifficultySelect();
                });
            }

            // å¤„ç†æ£‹ç›˜ç‚¹å‡»
            handleBoardClick(event) {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== BLACK) {
                    return;
                }

                const { x, y } = this.ui.getClickPosition(event);

                if (this.board.placeStone(x, y, BLACK)) {
                    this.passCount = 0;
                    this.ui.renderBoard(this.board);
                    this.ui.updateStatus(this.board, this.currentPlayer);

                    // åˆ‡æ¢åˆ° AI
                    this.currentPlayer = WHITE;
                    this.ui.updateStatus(this.board, this.currentPlayer);
                    this.ui.showMessage('AI æ€è€ƒä¸­...');

                    setTimeout(() => this.handleAIMove(), 500);
                } else {
                    this.ui.showMessage('æ— æ•ˆçš„è½å­ä½ç½®');
                }
            }

            // å¤„ç† AI è½å­
            handleAIMove() {
                if (this.gamePhase !== 'playing') return;

                const move = this.ai.selectMove();

                if (move) {
                    this.board.placeStone(move.x, move.y, WHITE);
                    this.passCount = 0;
                    this.ui.renderBoard(this.board);
                    this.ui.showMessage('AI è½å­å®Œæˆ');
                } else {
                    this.passCount++;
                    this.ui.showMessage('AI é€‰æ‹©åœç€');

                    if (this.passCount >= 2) {
                        this.endGame();
                        return;
                    }
                }

                this.currentPlayer = BLACK;
                this.ui.updateStatus(this.board, this.currentPlayer);
            }

            // å¤„ç†åœç€
            handlePass() {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== BLACK) {
                    return;
                }

                this.passCount++;
                this.ui.showMessage('ä½ é€‰æ‹©äº†åœç€');

                if (this.passCount >= 2) {
                    this.endGame();
                    return;
                }

                // åˆ‡æ¢åˆ° AI
                this.currentPlayer = WHITE;
                this.ui.updateStatus(this.board, this.currentPlayer);

                setTimeout(() => this.handleAIMove(), 500);
            }

            // å¤„ç†æ‚”æ£‹
            handleUndo() {
                if (this.gamePhase !== 'playing') return;

                // æ’¤é”€ AI çš„è½å­
                if (this.board.undo()) {
                    // æ’¤é”€ç©å®¶çš„è½å­
                    if (this.board.undo()) {
                        this.currentPlayer = BLACK;
                        this.passCount = 0;
                        this.ui.renderBoard(this.board);
                        this.ui.updateStatus(this.board, this.currentPlayer);
                        this.ui.showMessage('æ‚”æ£‹æˆåŠŸ');
                    } else {
                        // æ¢å¤ AI çš„è½å­
                        this.board.placeStone(
                            this.board.history[this.board.history.length - 1].x,
                            this.board.history[this.board.history.length - 1].y,
                            WHITE
                        );
                        this.ui.showMessage('æ— æ³•æ‚”æ£‹');
                    }
                } else {
                    this.ui.showMessage('æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ­¥æ•°');
                }
            }

            // ç»“æŸæ¸¸æˆ
            endGame() {
                this.gamePhase = 'finished';

                const territory = this.board.countTerritory();
                const blackScore = territory.black + this.board.captures.black;
                const whiteScore = territory.white + this.board.captures.white + 6.5; // è´´ç›®

                const result = {
                    winner: blackScore > whiteScore ? BLACK : WHITE,
                    blackScore,
                    whiteScore,
                    captures: this.board.captures
                };

                this.ui.showGameOver(result);
            }

            // é‡æ–°å¼€å§‹
            restart() {
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, this.difficulty);
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';
                this.passCount = 0;

                this.ui.initBoard();
                this.ui.renderBoard(this.board);
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            // è¿”å›éš¾åº¦é€‰æ‹©
            backToDifficultySelect() {
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('difficulty-modal').classList.remove('hidden');
            }
        }

        // ==================== å…¨å±€æ¸¸æˆå®ä¾‹å’Œå¼€å§‹å‡½æ•° ====================
        let game = null;

        function startGame(difficulty) {
            // éšè—éš¾åº¦é€‰æ‹©ç•Œé¢
            document.getElementById('difficulty-modal').classList.add('hidden');

            // æ˜¾ç¤ºæ¸¸æˆå®¹å™¨
            document.getElementById('game-container').style.display = 'block';

            // åˆ›å»ºæ¸¸æˆå®ä¾‹
            game = new GameController(difficulty);
        }

        // ==================== åˆå§‹åŒ–æ¸¸æˆ ====================
        // é¡µé¢åŠ è½½æ—¶ä¸è‡ªåŠ¨åˆå§‹åŒ–ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©éš¾åº¦
    </script>
</body>
</html>