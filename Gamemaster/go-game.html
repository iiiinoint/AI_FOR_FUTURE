<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›´æ£‹ - äººæœºå¯¹æˆ˜</title>
    <style>
        /* ==================== CSS Variables ==================== */
        :root {
            /* æµ…è‰²æ¨¡å¼é…è‰² */
            --bg-primary: #F5F5F7;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #E8E8ED;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --text-tertiary: #C7C7CC;
            --system-blue: #007AFF;
            --system-blue-hover: #0051D5;
            --system-blue-active: #004FC4;

            /* è¯­ä¹‰é…è‰² */
            --success-green: #34C759;
            --warning-orange: #FF9500;
            --danger-red: #FF3B30;
        }

        /* ==================== Global Styles ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display',
                         'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: var(--text-primary);
        }

        #game-container {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            border-radius: 24px;
            padding: 40px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 32px rgba(0, 0, 0, 0.08);
            max-width: 920px;
            width: 100%;
            animation: pageTransition 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes pageTransition {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 32px;
            font-size: 40px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        /* ==================== Game Info Cards ==================== */
        .game-info {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 32px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 20px;
        }

        .info-item {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .info-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
        }

        .info-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            font-feature-settings: 'tnum';
        }

        /* ==================== Board ==================== */
        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 32px;
        }

        #go-board {
            position: relative;
            background: linear-gradient(135deg, #E8C969 0%, #D4AF37 50%, #C9A227 100%);
            background-image:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.02) 2px,
                    rgba(0, 0, 0, 0.02) 4px
                );
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.12),
                0 24px 48px rgba(0, 0, 0, 0.16),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            cursor: pointer;
            user-select: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
        }

        .grid-line.horizontal {
            height: 1px;
            left: 20px;
            right: 20px;
        }

        .grid-line.vertical {
            width: 1px;
            top: 20px;
            bottom: 20px;
        }

        .star-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .stone {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s cubic-bezier(0.25, 0.1, 0.25, 1);
            cursor: default;
            animation: stonePlace 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes stonePlace {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .stone.black {
            background: radial-gradient(circle at 35% 35%, #4A4A4A 0%, #1D1D1F 40%, #000000 100%);
            box-shadow:
                0 0 0 1px rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 8px 16px rgba(0, 0, 0, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .stone.white {
            background: radial-gradient(circle at 35% 35%, #FFFFFF 0%, #F5F5F7 40%, #E8E8ED 100%);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.2),
                0 8px 16px rgba(0, 0, 0, 0.15),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: var(--system-blue);
            border-radius: 50%;
            box-shadow:
                0 0 0 3px rgba(0, 122, 255, 0.3),
                0 0 12px rgba(0, 122, 255, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow:
                    0 0 0 3px rgba(0, 122, 255, 0.3),
                    0 0 12px rgba(0, 122, 255, 0.5);
            }
            50% {
                box-shadow:
                    0 0 0 5px rgba(0, 122, 255, 0.2),
                    0 0 20px rgba(0, 122, 255, 0.4);
            }
        }

        /* ==================== Controls ==================== */
        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 24px;
            font-size: 17px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: var(--system-blue);
            color: white;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        button:hover {
            background: var(--system-blue-hover);
            transform: translateY(-1px);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        button:active {
            background: var(--system-blue-active);
            transform: scale(0.97);
            transition: transform 0.1s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        button:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: var(--text-tertiary);
            transform: none;
        }

        .status {
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: var(--text-secondary);
            min-height: 24px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .status.highlight {
            color: var(--system-blue);
            background: rgba(0, 122, 255, 0.1);
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ==================== Modal ==================== */
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            padding: 48px;
            border-radius: 24px;
            text-align: center;
            max-width: 480px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 32px rgba(0, 0, 0, 0.08);
            animation: slideUp 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(40px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-content h2 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--text-primary);
        }

        .result-details {
            margin: 24px 0;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .winner {
            font-size: 48px;
            font-weight: 800;
            margin: 24px 0;
            letter-spacing: -1px;
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 50%, #AF52DE 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 32px;
        }

        .modal-btn {
            padding: 16px 32px;
            font-size: 17px;
            font-weight: 600;
            background: var(--system-blue);
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .modal-btn:hover {
            background: var(--system-blue-hover);
            transform: translateY(-1px);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .modal-btn:active {
            transform: scale(0.97);
        }

        /* ==================== Difficulty Selection ==================== */
        #difficulty-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #difficulty-modal.hidden {
            display: none;
        }

        .difficulty-content {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            padding: 60px 50px;
            border-radius: 24px;
            text-align: center;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 24px rgba(0, 0, 0, 0.06);
            animation: slideUp 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
            max-width: 540px;
            width: 90%;
        }

        .difficulty-content h1 {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 50%, #AF52DE 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .difficulty-content h2 {
            font-size: 28px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 48px;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .difficulty-btn {
            padding: 18px 28px;
            font-size: 17px;
            font-weight: 600;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            color: var(--text-primary);
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .difficulty-btn:hover {
            transform: scale(1.02);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .difficulty-btn:active {
            transform: scale(0.98);
            transition: transform 0.1s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.08) 100%);
            border: 1px solid rgba(52, 199, 89, 0.3);
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, rgba(255, 149, 0, 0.15) 0%, rgba(255, 149, 0, 0.08) 100%);
            border: 1px solid rgba(255, 149, 0, 0.3);
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.08) 100%);
            border: 1px solid rgba(255, 59, 48, 0.3);
        }

        .difficulty-description {
            margin-top: 4px;
            font-size: 14px;
            font-weight: 400;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        /* ==================== Responsive Design ==================== */
        @media (max-width: 768px) {
            #game-container {
                padding: 24px 16px;
                margin: 16px;
                border-radius: 20px;
            }

            h1 {
                font-size: 28px;
                margin-bottom: 24px;
            }

            .game-info {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                padding: 16px;
            }

            .info-item {
                padding: 12px;
            }

            .info-label {
                font-size: 11px;
            }

            .info-value {
                font-size: 20px;
            }

            .board-container {
                margin: 0 -16px;
                padding: 0 16px;
                overflow: hidden;
            }

            #go-board {
                max-width: 100%;
                height: auto;
            }

            .controls {
                gap: 8px;
            }

            button {
                padding: 12px 20px;
                font-size: 15px;
                flex: 1 1 calc(50% - 8px);
            }

            .modal-content {
                margin: 20px;
                padding: 32px 24px;
                border-radius: 20px;
            }

            .winner {
                font-size: 32px;
            }

            .difficulty-content {
                margin: 20px;
                padding: 40px 24px;
            }

            .difficulty-content h1 {
                font-size: 36px;
            }

            .difficulty-content h2 {
                font-size: 22px;
            }
        }

        @media (max-width: 375px) {
            .game-info {
                grid-template-columns: 1fr;
            }

            button {
                flex: 1 1 100%;
            }

            #go-board {
                border-radius: 12px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            #game-container {
                max-width: 700px;
                padding: 36px;
            }

            .game-info {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ==================== Accessibility ==================== */
        @media (prefers-contrast: high) {
            button {
                border: 2px solid currentColor;
            }

            .info-value {
                font-weight: 800;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .difficulty-btn {
                min-height: 48px;
                padding: 16px 24px;
            }
        }
    </style>
</head>
<body>
    <!-- éš¾åº¦é€‰æ‹©ç•Œé¢ -->
    <div id="difficulty-modal">
        <div class="difficulty-content">
            <h1>å›´æ£‹å¤§å¸ˆ</h1>
            <h2>é€‰æ‹©éš¾åº¦</h2>
            <div class="difficulty-buttons">
                <button class="difficulty-btn easy" onclick="startGame('easy')">
                    ç®€å•
                    <div class="difficulty-description">éšæœºè½å­ï¼Œé€‚åˆåˆå­¦è€…</div>
                </button>
                <button class="difficulty-btn medium" onclick="startGame('medium')">
                    ä¸­ç­‰
                    <div class="difficulty-description">ä¼šæå­å’Œé˜²å®ˆï¼Œæœ‰åŸºæœ¬ç­–ç•¥</div>
                </button>
                <button class="difficulty-btn hard" onclick="startGame('hard')">
                    å›°éš¾
                    <div class="difficulty-description">é«˜çº§ç­–ç•¥ï¼Œå–„äºåˆ‡æ–­å’Œå›´åœ°</div>
                </button>
            </div>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <h1>å›´æ£‹ äººæœºå¯¹æˆ˜</h1>

        <div class="game-info">
            <div class="info-item">
                <div class="info-label">å½“å‰å›åˆ</div>
                <div class="info-value" id="current-player">é»‘æ–¹ (ç©å®¶)</div>
            </div>
            <div class="info-item">
                <div class="info-label">é»‘æ–¹æå­</div>
                <div class="info-value" id="black-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">ç™½æ–¹æå­</div>
                <div class="info-value" id="white-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">æ‰‹æ•°</div>
                <div class="info-value" id="move-count">0</div>
            </div>
        </div>

        <div class="board-container">
            <div id="go-board"></div>
        </div>

        <div class="controls">
            <button id="undo-btn">æ‚”æ£‹</button>
            <button id="restart-btn">é‡æ–°å¼€å§‹</button>
            <button id="home-btn">è¿”å›ä¸»é¡µ</button>
        </div>

        <div class="status" id="status">ç‚¹å‡»æ£‹ç›˜è½å­ï¼Œé»‘æ–¹å…ˆè¡Œ</div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <div class="winner" id="winner"></div>
            <div class="result-details" id="result-details"></div>
            <div class="modal-buttons">
                <button class="modal-btn" id="modal-restart">å†æ¥ä¸€å±€</button>
                <button class="modal-btn" id="modal-home">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== å¸¸é‡å®šä¹‰ ====================
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        // ==================== GoBoard ç±» ====================
        class GoBoard {
            constructor(size = 13) {
                this.size = size;
                this.grid = Array(size).fill(null).map(() => Array(size).fill(EMPTY));
                this.koPoint = null;
                this.history = [];
                this.captures = { black: 0, white: 0 };
                this.lastMove = null;
            }

            // å¤åˆ¶æ£‹ç›˜
            clone() {
                const newBoard = new GoBoard(this.size);
                newBoard.grid = this.grid.map(row => [...row]);
                newBoard.koPoint = this.koPoint ? { ...this.koPoint } : null;
                newBoard.history = [...this.history];
                newBoard.captures = { ...this.captures };
                newBoard.lastMove = this.lastMove ? { ...this.lastMove } : null;
                return newBoard;
            }

            // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨æ£‹ç›˜å†…
            isOnBoard(x, y) {
                return x >= 0 && x < this.size && y >= 0 && y < this.size;
            }

            // è·å–æ£‹å­ç»„ï¼ˆæ³›æ´ªç®—æ³•ï¼‰
            getGroup(startX, startY) {
                const color = this.grid[startY][startX];
                if (color === EMPTY) return [];

                const group = [];
                const visited = new Set();
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (this.grid[y][x] === color) {
                        group.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];

                        neighbors.forEach(n => {
                            if (this.isOnBoard(n.x, n.y) && !visited.has(`${n.x},${n.y}`)) {
                                stack.push(n);
                            }
                        });
                    }
                }

                return group;
            }

            // è®¡ç®—æ°”æ•°
            getLiberties(group) {
                const liberties = new Set();

                group.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === EMPTY) {
                            liberties.add(`${n.x},${n.y}`);
                        }
                    });
                });

                return liberties.size;
            }

            // ==================== æ–°å¢ï¼šç»Ÿä¸€çš„æ°”æ•°è®¡ç®—å‡½æ•° ====================
            // ä½¿ç”¨ Flood Fill ç®—æ³•æ‰¾å‡º (x, y) æ‰€åœ¨çš„æ£‹å­ç»„å¹¶è®¡ç®—å…¶æ°”æ•°
            // è¿”å›: { liberties: number, group: Array, libertyPositions: Set }
            getGroupLiberties(x, y) {
                // è¾¹ç•Œæ£€æŸ¥
                if (!this.isOnBoard(x, y)) {
                    return { liberties: 0, group: [], libertyPositions: new Set() };
                }

                const color = this.grid[y][x];

                // å¦‚æœæ˜¯ç©ºä½ï¼Œæ²¡æœ‰æ°”
                if (color === EMPTY) {
                    return { liberties: 0, group: [], libertyPositions: new Set() };
                }

                // ä½¿ç”¨æ ˆå®ç°çš„ Flood Fill ç®—æ³•
                const group = [];           // å­˜å‚¨æ£‹å­ç»„ä¸­çš„æ‰€æœ‰æ£‹å­
                const libertyPositions = new Set();  // å­˜å‚¨æ°”çš„ä½ç½®ï¼ˆä½¿ç”¨Seté¿å…é‡å¤ï¼‰
                const visited = new Set();  // è®°å½•å·²è®¿é—®çš„ä½ç½®
                const stack = [{ x, y }];   // å¾…è®¿é—®çš„æ ˆ

                while (stack.length > 0) {
                    const { x: currX, y: currY } = stack.pop();
                    const key = `${currX},${currY}`;

                    // å¦‚æœå·²ç»è®¿é—®è¿‡ï¼Œè·³è¿‡
                    if (visited.has(key)) {
                        continue;
                    }
                    visited.add(key);

                    // æ£€æŸ¥å½“å‰ä½ç½®çš„æ£‹å­é¢œè‰²
                    const currentColor = this.grid[currY][currX];

                    if (currentColor === color) {
                        // åŒè‰²æ£‹å­ï¼šåŠ å…¥æ£‹å­ç»„ï¼Œå¹¶ç»§ç»­æœç´¢é‚»å±…
                        group.push({ x: currX, y: currY });

                        // å››ä¸ªæ–¹å‘ï¼šä¸Šä¸‹å·¦å³
                        const neighbors = [
                            { x: currX - 1, y: currY },
                            { x: currX + 1, y: currY },
                            { x: currX, y: currY - 1 },
                            { x: currX, y: currY + 1 }
                        ];

                        for (const neighbor of neighbors) {
                            const neighborKey = `${neighbor.x},${neighbor.y}`;

                            // åªå¤„ç†æœªè®¿é—®çš„ã€åœ¨æ£‹ç›˜å†…çš„ä½ç½®
                            if (this.isOnBoard(neighbor.x, neighbor.y) && !visited.has(neighborKey)) {
                                stack.push(neighbor);
                            }
                        }
                    } else if (currentColor === EMPTY) {
                        // ç©ºä½ï¼šè¿™æ˜¯ä¸€ä¸ªæ°”ï¼
                        libertyPositions.add(`${currX},${currY}`);
                    }
                    // å¦‚æœæ˜¯å¯¹æ–¹æ£‹å­ï¼Œä¸åšå¤„ç†
                }

                return {
                    liberties: libertyPositions.size,
                    group: group,
                    libertyPositions: libertyPositions
                };
            }

            // æ£€æµ‹æå­
            detectCaptures(x, y, placedColor) {
                const opponentColor = placedColor === BLACK ? WHITE : BLACK;
                const captured = [];

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                neighbors.forEach(n => {
                    if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === opponentColor) {
                        const group = this.getGroup(n.x, n.y);
                        const liberties = this.getLiberties(group);

                        if (liberties === 0) {
                            group.forEach(stone => {
                                if (!captured.some(c => c.x === stone.x && c.y === stone.y)) {
                                    captured.push(stone);
                                }
                            });
                        }
                    }
                });

                return captured;
            }

            // ç§»é™¤æ£‹å­ç»„
            removeGroup(group) {
                group.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });
            }

            // è·å–æ£‹ç›˜å“ˆå¸Œå€¼ï¼ˆç”¨äºæ‰“åŠ«æ£€æµ‹ï¼‰
            getBoardHash() {
                return this.grid.map(row => row.join('')).join('|');
            }

            // è½å­
            placeStone(x, y, color) {
                const colorName = color === BLACK ? 'é»‘' : 'ç™½';
                const debug = color === WHITE; // åªä¸ºç™½æ£‹ï¼ˆAIï¼‰æ‰“å°è¯¦ç»†æ—¥å¿—

                if (debug) console.log(`   [è½å­éªŒè¯] å°è¯•${colorName}æ£‹åœ¨ (${x}, ${y})`);

                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    if (debug) console.log(`   [è½å­éªŒè¯] âŒ ä½ç½®æ— æ•ˆæˆ–å·²è¢«å ç”¨`);
                    return false;
                }

                // æ”¾ç½®æ£‹å­
                this.grid[y][x] = color;

                // æ£€æŸ¥æå­ï¼ˆåœ¨è½å­åï¼‰
                const captured = this.detectCaptures(x, y, color);
                if (debug && captured.length > 0) {
                    console.log(`   [è½å­éªŒè¯] ğŸ¯ å¯æ ${captured.length} å­: ${captured.map(c => `(${c.x},${c.y})`).join(', ')}`);
                }

                // æ£€æŸ¥è‡ªæ€ï¼ˆå¦‚æœæ²¡æœ‰æå­ä¸”è‡ªå·±ä¹Ÿæ²¡æ°”äº†ï¼‰
                if (captured.length === 0) {
                    const group = this.getGroup(x, y);
                    const liberties = this.getLiberties(group);
                    if (debug) console.log(`   [è½å­éªŒè¯] æ£‹å­ç»„å¤§å°: ${group.length}, æ°”æ•°: ${liberties}`);

                    if (liberties === 0) {
                        // æ’¤é”€è½å­
                        this.grid[y][x] = EMPTY;
                        if (debug) console.log(`   [è½å­éªŒè¯] âŒ è‡ªæ€ä½ç½®ï¼Œæ‹’ç»`);
                        return false;
                    }
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    // æ’¤é”€è½å­å’Œæå­
                    this.grid[y][x] = EMPTY;
                    captured.forEach(stone => {
                        this.grid[stone.y][stone.x] = (color === BLACK ? WHITE : BLACK);
                    });
                    if (debug) console.log(`   [è½å­éªŒè¯] âŒ æ‰“åŠ«ä½ç½®ï¼Œæ‹’ç» (åŠ«ç‚¹: ${this.koPoint.x},${this.koPoint.y})`);
                    return false;
                }

                // ç§»é™¤è¢«æçš„å­
                captured.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });

                // æ›´æ–°æå­æ•°
                if (color === BLACK) {
                    this.captures.black += captured.length;
                } else {
                    this.captures.white += captured.length;
                }

                // æ›´æ–°æ‰“åŠ«ç‚¹
                if (captured.length === 1) {
                    const opponentsGroups = [];
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === (color === BLACK ? WHITE : BLACK)) {
                            opponentsGroups.push(this.getGroup(n.x, n.y));
                        }
                    });

                    const ownGroup = this.getGroup(x, y);
                    if (ownGroup.length === 1 && this.getLiberties(ownGroup) === 1 && opponentsGroups.some(g => g.length === 1)) {
                        this.koPoint = captured[0];
                        if (debug) console.log(`   [è½å­éªŒè¯] âš ï¸ æ‰“åŠ«å‘ç”Ÿï¼ŒåŠ«ç‚¹è®¾ç½®ä¸º (${this.koPoint.x},${this.koPoint.y})`);
                    } else {
                        this.koPoint = null;
                    }
                } else {
                    this.koPoint = null;
                }

                // è®°å½•å†å²
                this.history.push({
                    x, y, color,
                    captures: captured,
                    boardHash: this.getBoardHash()
                });

                this.lastMove = { x, y };

                if (debug) console.log(`   [è½å­éªŒè¯] âœ… è½å­æˆåŠŸ`);
                return true;
            }

            // éªŒè¯è½å­æ˜¯å¦åˆæ³•
            isValidMove(x, y, color) {
                // æ£€æŸ¥ä½ç½®æ˜¯å¦ä¸ºç©º
                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    return false;
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    return false;
                }

                // æ£€æŸ¥è‡ªæ€
                const tempBoard = this.clone();
                tempBoard.grid[y][x] = color;
                const captures = tempBoard.detectCaptures(x, y, color);

                if (captures.length === 0) {
                    const group = tempBoard.getGroup(x, y);
                    const liberties = tempBoard.getLiberties(group);
                    if (liberties === 0) {
                        return false;
                    }
                }

                return true;
            }

            // æ•°åœ°
            countTerritory() {
                const territory = { black: 0, white: 0 };
                const visited = new Set();

                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const key = `${x},${y}`;
                        if (this.grid[y][x] === EMPTY && !visited.has(key)) {
                            const region = this.getEmptyRegion(x, y, visited);
                            const owner = this.determineTerritoryOwner(region);

                            if (owner === BLACK) {
                                territory.black += region.length;
                            } else if (owner === WHITE) {
                                territory.white += region.length;
                            }
                        }
                    }
                }

                return territory;
            }

            // è·å–ç©ºåœ°åŒºåŸŸ
            getEmptyRegion(startX, startY, visited) {
                const region = [];
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key) || !this.isOnBoard(x, y)) continue;

                    if (this.grid[y][x] === EMPTY) {
                        visited.add(key);
                        region.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];
                        neighbors.forEach(n => stack.push(n));
                    }
                }

                return region;
            }

            // åˆ¤æ–­åœ°åŸŸå½’å±
            determineTerritoryOwner(region) {
                const surroundingColors = new Set();

                region.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] !== EMPTY) {
                            surroundingColors.add(this.grid[n.y][n.x]);
                        }
                    });
                });

                if (surroundingColors.size === 1) {
                    return surroundingColors.values().next().value;
                }

                return null;
            }

            // æ’¤é”€ä¸Šä¸€æ­¥
            undo() {
                if (this.history.length === 0) return false;

                const lastMove = this.history.pop();

                // æ¢å¤æ£‹ç›˜çŠ¶æ€
                this.grid[lastMove.y][lastMove.x] = EMPTY;

                // æ¢å¤è¢«æçš„å­
                const opponentColor = lastMove.color === BLACK ? WHITE : BLACK;
                lastMove.captures.forEach(stone => {
                    this.grid[stone.y][stone.x] = opponentColor;
                });

                // æ›´æ–°æå­æ•°
                if (lastMove.color === BLACK) {
                    this.captures.black -= lastMove.captures.length;
                } else {
                    this.captures.white -= lastMove.captures.length;
                }

                // æ›´æ–°æœ€åè½å­ä½ç½®
                this.lastMove = this.history.length > 0 ? {
                    x: this.history[this.history.length - 1].x,
                    y: this.history[this.history.length - 1].y
                } : null;

                return true;
            }
        }

        // ==================== GoAI ç±» ====================
        class GoAI {
            constructor(color, board, difficulty = 'medium') {
                this.color = color;
                this.board = board;
                this.difficulty = difficulty;
                this.opponentColor = color === BLACK ? WHITE : BLACK;
            }

            // é€‰æ‹©è½å­ï¼ˆæ ¹æ®éš¾åº¦ï¼‰
            selectMove() {
                console.log(`ğŸ¤– AIå¼€å§‹æ€è€ƒ... éš¾åº¦: ${this.difficulty}`);

                let move;
                switch (this.difficulty) {
                    case 'easy':
                        move = this.selectMoveEasy();
                        break;
                    case 'medium':
                        move = this.selectMoveMedium();
                        break;
                    case 'hard':
                        move = this.selectMoveHard();
                        break;
                    default:
                        move = this.selectMoveMedium();
                }

                if (move) {
                    console.log(`âœ… AIå†³å®šè½å­äº: (${move.x}, ${move.y}), å¾—åˆ†: ${move.score ? move.score.toFixed(2) : 'N/A'}`);
                } else {
                    console.log(`âš ï¸ AIæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è½å­ä½ç½®ï¼Œé€‰æ‹©åœç€`);
                }

                return move;
            }

            // ==================== ç®€å•éš¾åº¦ ====================
            // ä»…è¯†åˆ« Atari å’Œ Rescueï¼Œå…¶ä½™éšæœºé€‰æ‹©åˆæ³•ç‚¹
            selectMoveEasy() {
                console.log(`   [ç®€å•æ¨¡å¼] å¼€å§‹å†³ç­–...`);
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (!this.board.isValidMove(x, y, this.color)) continue;

                        let score = this.getPositionalValue(x, y);

                        // æ£€æŸ¥ Atariï¼ˆæ‰“åƒå¯¹æ–¹ï¼‰
                        if (this.checkAtari(x, y)) {
                            score += 50;
                            console.log(`   [ç®€å•æ¨¡å¼] å‘ç°Atari: (${x}, ${y})`);
                        }

                        // æ£€æŸ¥ Rescueï¼ˆæ•‘æ´å·±æ–¹ï¼‰
                        if (this.checkRescue(x, y)) {
                            score += 80;
                            console.log(`   [ç®€å•æ¨¡å¼] å‘ç°Rescue: (${x}, ${y})`);
                        }

                        // æ·»åŠ éšæœºæ€§
                        score += Math.random() * 10;

                        candidates.push({ x, y, score });
                    }
                }

                if (candidates.length === 0) {
                    console.log(`   [ç®€å•æ¨¡å¼] âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                    return null;
                }

                candidates.sort((a, b) => b.score - a.score);
                const best = candidates[0];
                console.log(`   [ç®€å•æ¨¡å¼] æœ€ä½³ä½ç½®: (${best.x}, ${best.y}), å¾—åˆ†: ${best.score.toFixed(2)}`);
                return best;
            }

            // ==================== ä¸­ç­‰éš¾åº¦ ====================
            // åº”ç”¨æ‰€æœ‰æˆ˜æœ¯åˆ¤å®šï¼Œå¹¶åŠ å…¥åŸºæœ¬çš„å®‰å…¨æ£€æŸ¥
            selectMoveMedium() {
                console.log(`   [ä¸­ç­‰æ¨¡å¼] å¼€å§‹å†³ç­–...`);
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (!this.board.isValidMove(x, y, this.color)) continue;

                        let score = 0;

                        // æˆ˜æœ¯1ï¼šæ£€æŸ¥ Captureï¼ˆæå­ï¼‰
                        const captureCount = this.checkCapture(x, y);
                        if (captureCount > 0) {
                            score += 100 * captureCount;
                        }

                        // æˆ˜æœ¯2ï¼šæ£€æŸ¥ Atariï¼ˆæ‰“åƒå¯¹æ–¹ï¼‰
                        if (this.checkAtari(x, y)) {
                            score += 60;
                        }

                        // æˆ˜æœ¯3ï¼šæ£€æŸ¥ Rescueï¼ˆæ•‘æ´å·±æ–¹ï¼‰
                        if (this.checkRescue(x, y)) {
                            score += 90;
                        }

                        // æˆ˜æœ¯4ï¼šæ£€æŸ¥ Solid Connectionï¼ˆç²˜ï¼‰
                        if (this.checkConnection(x, y)) {
                            score += 20;
                        }

                        // 3x3æ¥è§¦æˆ˜æ£€æŸ¥ï¼šä¼˜å…ˆé€‰æ‹©ä¸å¯¹æ–¹æ£‹å­æ¥è§¦çš„ä½ç½®
                        if (this.hasOpponentIn3x3(x, y)) {
                            score += 15;
                        }

                        // ä½ç½®åˆ†ï¼ˆç®€åŒ–ç‰ˆï¼‰
                        const posScore = this.getPositionalScore(x, y);
                        score += posScore;

                        // æ·»åŠ å°‘é‡éšæœºæ€§
                        score += Math.random() * 5;

                        candidates.push({ x, y, score });
                    }
                }

                if (candidates.length === 0) {
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                    return null;
                }

                candidates.sort((a, b) => b.score - a.score);
                const best = candidates[0];
                console.log(`   [ä¸­ç­‰æ¨¡å¼] æœ€ä½³ä½ç½®: (${best.x}, ${best.y}), å¾—åˆ†: ${best.score.toFixed(2)}`);
                return best;
            }

            // ==================== å›°éš¾éš¾åº¦ ====================
            // ç–¯ç‹—æ¨¡å¼ï¼šæå…·ä¾µç•¥æ€§çš„è¿›æ”»AI
            selectMoveHard() {
                console.log(`   [å›°éš¾æ¨¡å¼] ğŸ• ç–¯ç‹—æ¨¡å¼å¯åŠ¨ - å¯»æ‰¾è¿›æ”»æœºä¼š...`);

                // æ”¶é›†æ‰€æœ‰å€™é€‰ç‚¹å¹¶è¯„åˆ†
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (!this.board.isValidMove(x, y, this.color)) continue;

                        // è®¡ç®—ä¾µç•¥æ€§è¯„åˆ†
                        const aggressionScore = this.evaluateAggression(x, y);

                        // å¦‚æœæ˜¯è‡ªæ€ï¼Œè·³è¿‡ï¼ˆé™¤éèƒ½æå­ï¼‰
                        if (aggressionScore.isSuicide && aggressionScore.captureCount === 0) {
                            continue;
                        }

                        candidates.push({ x, y, score: aggressionScore.totalScore, details: aggressionScore });
                    }
                }

                if (candidates.length === 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                    return null;
                }

                // é€‰æ‹©æœ€é«˜åˆ†çš„ç‚¹
                candidates.sort((a, b) => b.score - a.score);
                const best = candidates[0];
                console.log(`   [å›°éš¾æ¨¡å¼] âœ… æ”»å‡»è½å­: (${best.x}, ${best.y}), æ€»åˆ†: ${best.score.toFixed(1)}`);
                return best;
            }

            // ==================== ä¾µç•¥æ€§è¯„ä¼°å‡½æ•° ====================
            // æ ¸å¿ƒï¼šè¿›æ”»æƒé‡ > é˜²å®ˆæƒé‡
            evaluateAggression(x, y) {
                let score = 0;
                let captureCount = 0;
                let isSuicide = false;

                // 1ï¸âƒ£ ä¼˜å…ˆçº§æœ€é«˜ï¼šåƒå­
                captureCount = this.checkCapture(x, y);
                if (captureCount > 0) {
                    score += 150 * captureCount; // å¤§å¹…æé«˜åƒå­æƒé‡
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) åƒå­: +${150 * captureCount}`);
                }

                // 2ï¸âƒ£ åˆ‡æ–­ç‚¹æ£€æµ‹ï¼ˆæˆ˜ç•¥æ”»å‡»ï¼‰
                const cutResult = this.checkCuttingPoint(x, y);
                if (cutResult.isCut) {
                    score += 200; // åˆ‡æ–­æƒé‡æé«˜
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) åˆ‡æ–­å¯¹æ–¹${cutResult.cutGroups}å—æ£‹: +200`);
                }

                // 3ï¸âƒ£ æ‰³å¤´æ£€æµ‹
                const isHane = this.checkHane(x, y);
                if (isHane) {
                    score += 80;
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) æ‰³å¤´: +80`);
                }

                // 4ï¸âƒ£ æ°”å·®å€¼æ”»å‡»ï¼šè®©å¯¹æ–¹å‡å°‘æ°”
                const libertyDiff = this.calculateLibertyDifferential(x, y);
                score += libertyDiff * 50; // æ¯å‡å°‘å¯¹æ–¹1å£æ°” = +50åˆ†
                if (libertyDiff > 0) {
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) å‹ç¼©å¯¹æ–¹æ°”æ•°-${libertyDiff}: +${libertyDiff * 50}`);
                }

                // 5ï¸âƒ£ æ‰“åƒï¼ˆè®©å¯¹æ–¹åªå‰©1å£æ°”ï¼‰
                const isAtari = this.checkAtari(x, y);
                if (isAtari) {
                    score += 100;
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) æ‰“åƒå¯¹æ–¹: +100`);
                }

                // 6ï¸âƒ£ é˜²å®ˆæƒé‡ï¼ˆå¤§å¹…é™ä½ï¼‰
                const isRescue = this.checkRescue(x, y);
                if (isRescue) {
                    score += 30; // ä»100é™åˆ°30
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) æ•‘æ´: +30`);
                }

                // 7ï¸âƒ£ å¯¹æ€åˆ¤æ–­ï¼šå¦‚æœè‡ªå·±æ°”æ•°æ¯”å¯¹æ–¹å¤šï¼Œåšå†³å¯¹æ€
                const fightResult = this.evaluateFight(x, y);
                if (fightResult.canWin) {
                    score += 120;
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) å¯¹æ€å¯èµ¢(å·±${fightResult.myLiberties}æ°” vs æ•Œ${fightResult.enemyLiberties}æ°”): +120`);
                } else if (fightResult.canLose) {
                    score -= 500; // å¯¹æ€ä¼šè¾“ï¼Œå¤§å¹…æ‰£åˆ†
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) å¯¹æ€ä¼šè¾“: -500`);
                }

                // 8ï¸âƒ£ æ£€æŸ¥æ˜¯å¦è‡ªæ€
                const tempBoard = this.board.clone();
                if (tempBoard.placeStone(x, y, this.color)) {
                    const myGroup = tempBoard.getGroupLiberties(x, y);
                    if (myGroup.liberties === 0) {
                        isSuicide = true;
                    } else if (myGroup.liberties === 1) {
                        // åªæœ‰1å£æ°”ï¼Œä½†è¦æ£€æŸ¥èƒ½å¦æå­
                        if (captureCount === 0) {
                            score -= 300; // æå…¶å±é™©ï¼Œå¤§å¹…æ‰£åˆ†
                            console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) åªæœ‰1å£æ°”: -300`);
                        }
                    }
                }

                // 9ï¸âƒ£ ä½ç½®æƒé‡ï¼ˆé™ä½ï¼‰
                const posScore = this.getPositionalScore(x, y);
                score += posScore * 0.3; // ä½ç½®æƒé‡é™ä¸º30%

                // ğŸ”Ÿ è´´è¿‘å¯¹æ‰‹åŠ åˆ†ï¼ˆé¼“åŠ±è´´èº«è‚‰æï¼‰
                if (this.isAdjacentToOpponent(x, y)) {
                    score += 20;
                    console.log(`   [ä¾µç•¥æ€§è¯„ä¼°] (${x},${y}) è´´è¿‘å¯¹æ‰‹: +20`);
                }

                return { totalScore: score, captureCount, isSuicide };
            }

            // ==================== æ°”å·®å€¼æ”»å‡» ====================
            // è®¡ç®—è½å­åå¯¹æ–¹ç›¸é‚»æ£‹å­æ€»å…±å‡å°‘å¤šå°‘æ°”
            calculateLibertyDifferential(x, y) {
                let totalReduction = 0;

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                for (const n of neighbors) {
                    if (!this.board.isOnBoard(n.x, n.y)) continue;
                    if (this.board.grid[n.y][n.x] !== this.opponentColor) continue;

                    // è·å–è½å­å‰å¯¹æ–¹çš„æ°”æ•°
                    const beforeLiberties = this.board.getGroupLiberties(n.x, n.y).liberties;

                    // è·å–è½å­åå¯¹æ–¹çš„æ°”æ•°
                    const tempBoard = this.board.clone();
                    if (tempBoard.placeStone(x, y, this.color)) {
                        const afterLiberties = tempBoard.getGroupLiberties(n.x, n.y).liberties;
                        const reduction = beforeLiberties - afterLiberties;
                        totalReduction += reduction;
                    }
                }

                return totalReduction;
            }

            // ==================== åˆ‡æ–­ç‚¹æ£€æµ‹ ====================
            // æ£€æŸ¥è½å­åèƒ½å¦åˆ‡æ–­å¯¹æ–¹
            checkCuttingPoint(x, y) {
                const tempBoard = this.board.clone();
                if (!tempBoard.placeStone(x, y, this.color)) {
                    return { isCut: false, cutGroups: 0 };
                }

                // æ£€æŸ¥å¯¹è§’çº¿ä½ç½®æ˜¯å¦æœ‰å¯¹æ–¹çš„æ£‹å­
                const diagonals = [
                    { x: x - 1, y: y - 1 }, { x: x + 1, y: y - 1 },
                    { x: x - 1, y: y + 1 }, { x: x + 1, y: y + 1 }
                ];

                let opponentGroups = [];
                const visited = new Set();

                for (const d of diagonals) {
                    if (!tempBoard.isOnBoard(d.x, d.y)) continue;
                    if (tempBoard.grid[d.y][d.x] !== this.opponentColor) continue;

                    const key = `${d.x},${d.y}`;
                    if (visited.has(key)) continue;

                    const group = tempBoard.getGroup(d.x, d.y);
                    group.forEach(stone => visited.add(`${stone.x},${stone.y}`));

                    opponentGroups.push(group);
                }

                // å¦‚æœæœ‰2ä¸ªæˆ–ä»¥ä¸Šçš„å¯¹æ–¹æ£‹å­ç»„åœ¨å››ä¸ªå¯¹è§’æ–¹å‘ï¼Œå¯èƒ½åˆ‡æ–­
                if (opponentGroups.length >= 2) {
                    // è¿›ä¸€æ­¥éªŒè¯ï¼šè¿™äº›æ£‹å­ç»„åœ¨è½å­å‰æ˜¯å¦è¿é€š
                    const beforeBoard = this.board.clone();
                    let wasConnected = false;

                    // æ£€æŸ¥è¿™äº›æ£‹å­ç»„åœ¨è½å­å‰æ˜¯å¦å±äºåŒä¸€ä¸ªç»„
                    if (opponentGroups.length >= 2) {
                        const firstGroup = beforeBoard.getGroup(opponentGroups[0][0].x, opponentGroups[0][0].y);

                        for (let i = 1; i < opponentGroups.length; i++) {
                            const secondStone = opponentGroups[i][0];
                            if (firstGroup.some(s => s.x === secondStone.x && s.y === secondStone.y)) {
                                wasConnected = true;
                                break;
                            }
                        }
                    }

                    if (wasConnected) {
                        return { isCut: true, cutGroups: opponentGroups.length };
                    }
                }

                return { isCut: false, cutGroups: 0 };
            }

            // ==================== æ‰³å¤´æ£€æµ‹ ====================
            // æ£€æŸ¥æ˜¯å¦åœ¨å¯¹æ–¹æ£‹å­åºåˆ—çš„"å¤´"ä¸Šè½å­
            checkHane(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                // æ£€æŸ¥ç›¸é‚»ä½ç½®æ˜¯å¦æœ‰å¯¹æ–¹æ£‹å­
                for (const n of neighbors) {
                    if (!this.board.isOnBoard(n.x, n.y)) continue;
                    if (this.board.grid[n.y][n.x] !== this.opponentColor) continue;

                    // æ£€æŸ¥å¯¹æ–¹æ£‹å­æ˜¯å¦æœ‰ä¸€æ’ï¼ˆ2ä¸ªæˆ–ä»¥ä¸Šï¼‰
                    const group = this.board.getGroup(n.x, n.y);
                    if (group.length >= 2) {
                        // æ£€æŸ¥è¿™æ’æ£‹å­çš„å»¶ä¼¸æ–¹å‘
                        // å¦‚æœè½å­åœ¨å¯¹æ–¹æ£‹å­çš„"å¤´"ä¸Šï¼Œå°±æ˜¯æ‰³
                        return true;
                    }
                }

                return false;
            }

            // ==================== å¯¹æ€è¯„ä¼° ====================
            // æ£€æŸ¥æ˜¯å¦èƒ½èµ¢ä¸‹å¯¹æ€
            evaluateFight(x, y) {
                const tempBoard = this.board.clone();
                if (!tempBoard.placeStone(x, y, this.color)) {
                    return { canWin: false, canLose: false, myLiberties: 0, enemyLiberties: 0 };
                }

                // è·å–å·±æ–¹æ£‹å­ç»„çš„æ°”æ•°
                const myGroup = tempBoard.getGroupLiberties(x, y);
                const myLiberties = myGroup.liberties;

                // è·å–ç›¸é‚»å¯¹æ–¹æ£‹å­ç»„çš„æ°”æ•°
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                let minEnemyLiberties = Infinity;

                for (const n of neighbors) {
                    if (!tempBoard.isOnBoard(n.x, n.y)) continue;
                    if (tempBoard.grid[n.y][n.x] !== this.opponentColor) continue;

                    const enemyGroup = tempBoard.getGroupLiberties(n.x, n.y);
                    minEnemyLiberties = Math.min(minEnemyLiberties, enemyGroup.liberties);
                }

                if (minEnemyLiberties === Infinity) {
                    // æ²¡æœ‰ç›¸é‚»å¯¹æ–¹æ£‹å­ï¼Œä¸ç®—å¯¹æ€
                    return { canWin: false, canLose: false, myLiberties, enemyLiberties: 0 };
                }

                return {
                    canWin: myLiberties > minEnemyLiberties,
                    canLose: myLiberties < minEnemyLiberties,
                    myLiberties,
                    enemyLiberties: minEnemyLiberties
                };
            }

            // ==================== æ£€æŸ¥æ˜¯å¦è´´è¿‘å¯¹æ‰‹ ====================
            isAdjacentToOpponent(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                for (const n of neighbors) {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] === this.opponentColor) {
                        return true;
                    }
                }

                return false;
            }

            // ==================== æ¨¡æ‹Ÿé¢„åˆ¤å±‚ ====================
            // æ£€æŸ¥è½å­æ˜¯å¦å®‰å…¨ï¼ˆè€ƒè™‘å¯¹æ‰‹åå‡»ï¼‰
            isMoveSafe(board, x, y, color) {
                const opponentColor = color === BLACK ? WHITE : BLACK;

                // è™šæ‹Ÿè½å­
                const tempBoard = board.clone();
                if (!tempBoard.placeStone(x, y, color)) {
                    return { safe: false, reason: 'æ— æ³•è½å­' };
                }

                // æ£€æŸ¥1ï¼šè½å­åçš„æ£‹å­æ°”æ•°
                const myGroupResult = tempBoard.getGroupLiberties(x, y);
                if (myGroupResult.liberties === 0) {
                    return { safe: false, reason: 'è‡ªæ€' };
                }

                // æ£€æŸ¥2ï¼šå¦‚æœåªæœ‰1å£æ°”ï¼Œæ£€æŸ¥å¯¹æ‰‹èƒ½å¦ç«‹åˆ»æèµ°ï¼ˆSnapback/å€’æ‰‘ï¼‰
                if (myGroupResult.liberties === 1) {
                    // æ‰¾åˆ°é‚£ä¸ªå”¯ä¸€çš„æ°”
                    const myLiberties = Array.from(myGroupResult.libertyPositions);
                    if (myLiberties.length === 1) {
                        const [libertyX, libertyY] = myLiberties[0].split(',').map(Number);

                        // æ£€æŸ¥å¯¹æ‰‹èƒ½å¦åœ¨é‚£ä¸ªä½ç½®è½å­æèµ°æˆ‘æ–¹æ£‹å­
                        const checkBoard = tempBoard.clone();
                        if (checkBoard.isValidMove(libertyX, libertyY, opponentColor)) {
                            if (checkBoard.placeStone(libertyX, libertyY, opponentColor)) {
                                // æ£€æŸ¥æå­æ•°é‡
                                const captures = checkBoard.detectCaptures(libertyX, libertyY, opponentColor);
                                if (captures.length >= myGroupResult.group.length) {
                                    return { safe: false, reason: 'å€’æ‰‘ï¼šå¯¹æ‰‹å¯åæ' };
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥3ï¼šæ˜¯å¦è®©å·±æ–¹å…¶ä»–æ£‹å­ç»„æ°”æ•°å˜å°‘
                // è·å–è½å­å‰å·±æ–¹æ‰€æœ‰æ£‹å­ç»„çš„æ°”æ•°
                const beforeGroups = this.getAllGroupLiberties(board, color);

                // è·å–è½å­åå·±æ–¹æ‰€æœ‰æ£‹å­ç»„çš„æ°”æ•°
                const afterGroups = this.getAllGroupLiberties(tempBoard, color);

                // æ¯”è¾ƒæ˜¯å¦æœ‰æ£‹å­ç»„æ°”æ•°å‡å°‘
                for (const key in beforeGroups) {
                    if (afterGroups[key] !== undefined && afterGroups[key] < beforeGroups[key]) {
                        return { safe: false, reason: `æ°”æ•°å‡å°‘: ${beforeGroups[key]}â†’${afterGroups[key]}` };
                    }
                }

                return { safe: true };
            }

            // è·å–æŸä¸€æ–¹æ‰€æœ‰æ£‹å­ç»„çš„æ°”æ•°
            getAllGroupLiberties(board, color) {
                const groupsLiberties = {};
                const visited = new Set();

                for (let y = 0; y < board.size; y++) {
                    for (let x = 0; x < board.size; x++) {
                        if (board.grid[y][x] === color) {
                            const key = `${x},${y}`;
                            if (visited.has(key)) continue;

                            const result = board.getGroupLiberties(x, y);
                            result.group.forEach(stone => visited.add(`${stone.x},${stone.y}`));

                            // ç”¨æ£‹å­ç»„çš„èµ·å§‹ä½ç½®ä½œä¸ºkey
                            const groupKey = `${result.group[0].x},${result.group[0].y}`;
                            groupsLiberties[groupKey] = result.liberties;
                        }
                    }
                }

                return groupsLiberties;
            }

            // ==================== æ£‹ç›˜ä»·å€¼å›¾ (Influence Map) ====================
            // è®¡ç®—ä½ç½®çš„åŸºç¡€ä»·å€¼ï¼ŒåŸºäºä¸­å¿ƒè·ç¦»ã€æ˜Ÿä½ã€è¾¹ç¼˜ç­‰
            getPositionalValue(x, y) {
                let value = 0;

                // 1. ä¸­å¿ƒä½ç½®åŠ åˆ†
                const center = Math.floor(this.board.size / 2);
                const distFromCenter = Math.abs(x - center) + Math.abs(y - center);
                value += (this.board.size - distFromCenter) * 2;

                // 2. æ˜Ÿä½åŠ åˆ†
                if (this.isStarPoint(x, y)) {
                    value += 15;
                }

                // 3. æ­»äº¡çº¿ï¼ˆç¬¬ä¸€çº¿ï¼‰æä½æƒé‡
                if (x === 0 || x === this.board.size - 1 || y === 0 || y === this.board.size - 1) {
                    value -= 20;
                }

                // 4. ç¬¬äºŒçº¿è½»å¾®å‡åˆ†
                if (x === 1 || x === this.board.size - 2 || y === 1 || y === this.board.size - 2) {
                    value -= 5;
                }

                // 5. ç¬¬ä¸‰çº¿åˆ°ç¬¬äº”çº¿è¾ƒä¸ºç†æƒ³
                if ((x >= 2 && x <= 4) || (x >= this.board.size - 5 && x <= this.board.size - 3) ||
                    (y >= 2 && y <= 4) || (y >= this.board.size - 5 && y <= this.board.size - 3)) {
                    value += 3;
                }

                return value;
            }

            // ==================== ä½ç½®æƒé‡è¯„åˆ† ====================
            // é‡‘è§’é“¶è¾¹ + ç–å¯†åˆ¤æ–­
            getPositionalScore(x, y) {
                let score = 0;

                // 1. é‡‘è§’é“¶è¾¹ï¼šç¬¬3ã€4çº¿çš„äº¤ç‚¹ï¼ˆæ˜Ÿä½ã€å°ç›®ï¼‰
                const isThirdLine = (x === 3 || x === 9 || y === 3 || y === 9);
                const isFourthLine = (x === 4 || x === 8 || y === 4 || y === 8);

                // æ˜Ÿä½ï¼ˆç¬¬3çº¿äº¤ç‚¹ï¼‰
                if ((x === 3 || x === 9) && (y === 3 || y === 9)) {
                    score += 10;
                }
                // å°ç›®ï¼ˆç¬¬3çº¿å’Œç¬¬4çº¿çš„äº¤ç‚¹ï¼‰
                else if (isThirdLine && isFourthLine) {
                    score += 8;
                }
                // ç¬¬3çº¿å…¶ä»–ä½ç½®
                else if (isThirdLine) {
                    score += 5;
                }
                // ç¬¬4çº¿å…¶ä»–ä½ç½®
                else if (isFourthLine) {
                    score += 4;
                }

                // 2. ç–å¯†åˆ¤æ–­ï¼šè®¡ç®—å‘¨å›´2æ ¼èŒƒå›´å†…çš„æ£‹å­å¯†åº¦
                const density = this.calculateLocalDensity(x, y, 2);

                // å‘¨å›´è¶Šç©ºæ—·ï¼ŒåŠ åˆ†è¶Šå¤š
                if (density <= 1) {
                    score += 5;  // éå¸¸ç©ºæ—·
                } else if (density <= 3) {
                    score += 3;  // æ¯”è¾ƒç©ºæ—·
                } else if (density >= 6) {
                    score -= 3;  // å¤ªæ‹¥æŒ¤ï¼Œå‡åˆ†
                }

                // 3. é¿å…è´´ç€æ­»æ£‹ï¼ˆå¯¹æ–¹åªå‰©1å£æ°”çš„æ£‹å­ï¼‰
                if (this.isNearDeadStones(x, y)) {
                    score -= 8;
                }

                return score;
            }

            // è®¡ç®—å±€éƒ¨å¯†åº¦ï¼ˆå‘¨å›´radiusæ ¼èŒƒå›´å†…çš„æ£‹å­æ•°é‡ï¼‰
            calculateLocalDensity(x, y, radius) {
                let count = 0;

                for (let dy = y - radius; dy <= y + radius; dy++) {
                    for (let dx = x - radius; dx <= x + radius; dx++) {
                        if (this.board.isOnBoard(dx, dy) && !(dx === x && dy === y)) {
                            if (this.board.grid[dy][dx] !== EMPTY) {
                                count++;
                            }
                        }
                    }
                }

                return count;
            }

            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æ­»æ£‹ï¼ˆå¯¹æ–¹åªå‰©1å£æ°”çš„æ£‹å­ï¼‰
            isNearDeadStones(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                for (const n of neighbors) {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] === this.opponentColor) {
                        const result = this.board.getGroupLiberties(n.x, n.y);
                        if (result.liberties === 1) {
                            return true;
                        }
                    }
                }

                return false;
            }

            // åˆ¤æ–­æ˜¯å¦ä¸ºæ˜Ÿä½
            isStarPoint(x, y) {
                const size = this.board.size;
                const starPoints = size === 13 ?
                    [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]] :
                    size === 19 ?
                    [[3, 3], [9, 3], [15, 3], [3, 9], [9, 9], [15, 9], [3, 15], [9, 15], [15, 15]] :
                    [];
                return starPoints.some(p => p[0] === x && p[1] === y);
            }

            // ==================== æˆ˜æœ¯åˆ¤å®šå‡½æ•° ====================

            // æˆ˜æœ¯1ï¼šCaptureï¼ˆæå­ï¼‰- æ£€æŸ¥è½å­åèƒ½å¦æå­
            checkCapture(x, y) {
                const tempBoard = this.board.clone();
                if (!tempBoard.placeStone(x, y, this.color)) return 0;
                const captures = tempBoard.detectCaptures(x, y, this.color);
                return captures.length;
            }

            // æˆ˜æœ¯2ï¼šAtariï¼ˆæ‰“åƒï¼‰- æ£€æŸ¥è½å­åå¯¹æ–¹æ˜¯å¦åªå‰©1å£æ°”
            checkAtari(x, y) {
                const tempBoard = this.board.clone();
                if (!tempBoard.placeStone(x, y, this.color)) return false;

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                for (const n of neighbors) {
                    if (tempBoard.isOnBoard(n.x, n.y) && tempBoard.grid[n.y][n.x] === this.opponentColor) {
                        // ä½¿ç”¨æ–°çš„ getGroupLiberties å‡½æ•°
                        const result = tempBoard.getGroupLiberties(n.x, n.y);
                        if (result.liberties === 1) return true;
                    }
                }
                return false;
            }

            // æˆ˜æœ¯3ï¼šRescueï¼ˆæ•‘æ´ï¼‰- æ£€æŸ¥è½å­åèƒ½å¦å¢åŠ å·±æ–¹æ£‹å­çš„æ°”
            checkRescue(x, y) {
                // æ‰¾åˆ°æ‰€æœ‰å·±æ–¹åªå‰©ä½™1å£æ°”çš„æ£‹å­ç»„
                const criticalGroups = [];
                const visited = new Set();

                for (let dy = 0; dy < this.board.size; dy++) {
                    for (let dx = 0; dx < this.board.size; dx++) {
                        if (this.board.grid[dy][dx] === this.color) {
                            const key = `${dx},${dy}`;
                            if (visited.has(key)) continue;

                            // ä½¿ç”¨æ–°çš„ getGroupLiberties å‡½æ•°
                            const result = this.board.getGroupLiberties(dx, dy);
                            result.group.forEach(stone => visited.add(`${stone.x},${stone.y}`));

                            if (result.liberties === 1) {
                                criticalGroups.push(result);
                            }
                        }
                    }
                }

                // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦æ˜¯æŸä¸ªå±æ€¥æ£‹å­çš„æ°”
                for (const groupResult of criticalGroups) {
                    for (const stone of groupResult.group) {
                        const neighbors = [
                            { x: stone.x - 1, y: stone.y },
                            { x: stone.x + 1, y: stone.y },
                            { x: stone.x, y: stone.y - 1 },
                            { x: stone.x, y: stone.y + 1 }
                        ];

                        if (neighbors.some(n => n.x === x && n.y === y)) {
                            // éªŒè¯è½å­åæ°”æ•°å¢åŠ 
                            const tempBoard = this.board.clone();
                            if (tempBoard.placeStone(x, y, this.color)) {
                                // ä½¿ç”¨æ–°çš„ getGroupLiberties å‡½æ•°
                                const newResult = tempBoard.getGroupLiberties(stone.x, stone.y);
                                if (newResult.liberties > 1) return true;
                            }
                        }
                    }
                }
                return false;
            }

            // æˆ˜æœ¯4ï¼šSolid Connectionï¼ˆç²˜ï¼‰- æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥ä¸¤å—å·±æ–¹æ£‹å­
            checkConnection(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                let ownNeighborCount = 0;
                const connectedGroups = [];

                for (const n of neighbors) {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] === this.color) {
                        ownNeighborCount++;
                        const group = this.board.getGroup(n.x, n.y);
                        const groupKey = `${group[0].x},${group[0].y}`;
                        if (!connectedGroups.some(g => g === groupKey)) {
                            connectedGroups.push(groupKey);
                        }
                    }
                }

                // å¦‚æœæœ‰ä¸¤ä¸ªæˆ–æ›´å¤šç›¸é‚»çš„å·±æ–¹æ£‹å­ï¼Œä¸”å±äºä¸åŒçš„ç»„ï¼Œå¯ä»¥è¿æ¥
                return ownNeighborCount >= 2 && connectedGroups.length >= 2;
            }

            // æ£€æŸ¥3x3èŒƒå›´å†…æ˜¯å¦æœ‰å¯¹æ–¹æ£‹å­
            hasOpponentIn3x3(x, y) {
                for (let dy = y - 1; dy <= y + 1; dy++) {
                    for (let dx = x - 1; dx <= x + 1; dx++) {
                        if (this.board.isOnBoard(dx, dy) && this.board.grid[dy][dx] === this.opponentColor) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // ==================== çœ¼ä½è¯†åˆ« ====================
            // æ£€æŸ¥æ˜¯å¦åœ¨å¡«è‡ªå·±çš„çœŸçœ¼
            isFillingOwnEye(x, y) {
                // çœŸçœ¼çš„æ¡ä»¶ï¼šå››ä¸ªè§’éƒ½è¢«å·±æ–¹æ£‹å­å æ®ï¼Œæˆ–è€…è¾¹ç•Œ+å·±æ–¹æ£‹å­
                const corners = [
                    { x: x - 1, y: y - 1 },
                    { x: x + 1, y: y - 1 },
                    { x: x - 1, y: y + 1 },
                    { x: x + 1, y: y + 1 }
                ];

                // ç®€åŒ–çš„çœ¼ä½åˆ¤å®šï¼šæ£€æŸ¥ä¸Šä¸‹å·¦å³æ˜¯å¦éƒ½æ˜¯å·±æ–¹æ£‹å­æˆ–è¾¹ç•Œ
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                let ownCount = 0;
                let edgeCount = 0;

                for (const n of neighbors) {
                    if (!this.board.isOnBoard(n.x, n.y)) {
                        edgeCount++;
                    } else if (this.board.grid[n.y][n.x] === this.color) {
                        ownCount++;
                    }
                }

                // å¦‚æœå››ä¸ªæ–¹å‘éƒ½æ˜¯å·±æ–¹æˆ–è¾¹ç•Œï¼Œå¯èƒ½æ˜¯çœ¼
                if (ownCount + edgeCount === 4 && ownCount >= 2) {
                    // è¿›ä¸€æ­¥æ£€æŸ¥å¯¹è§’æ˜¯å¦ä¹Ÿæœ‰å·±æ–¹æ£‹å­
                    let diagonalOwn = 0;
                    for (const c of corners) {
                        if (this.board.isOnBoard(c.x, c.y) && this.board.grid[c.y][c.x] === this.color) {
                            diagonalOwn++;
                        }
                    }

                    // å¦‚æœæœ‰è¶³å¤Ÿçš„å¯¹è§’æ”¯æŒï¼Œå¾ˆå¯èƒ½æ˜¯çœŸçœ¼
                    if (diagonalOwn >= 2 || (edgeCount > 0 && diagonalOwn >= 1)) {
                        return true;
                    }
                }

                return false;
            }

            // ==================== Minimax é¢„åˆ¤ ====================
            // 1å±‚Minimaxï¼šé¢„åˆ¤è½å­åå¯¹æ–¹çš„æœ€ä½³å›åº”
            minimaxEvaluate(x, y, depth) {
                if (depth === 0) return 0;

                // æ¨¡æ‹Ÿå·±æ–¹è½å­
                const tempBoard = this.board.clone();
                if (!tempBoard.placeStone(x, y, this.color)) return -1000;

                // å¯»æ‰¾å¯¹æ–¹æœ€ä½³å›åº”
                let bestOpponentScore = -Infinity;
                let opponentMoveCount = 0;
                const maxOpponentMoves = 20; // åªè¯„ä¼°å‰20ä¸ªå¯¹æ–¹å¯èƒ½çš„å›åº”

                for (let dy = 0; dy < this.board.size; dy++) {
                    for (let dx = 0; dx < this.board.size; dx++) {
                        if (!tempBoard.isValidMove(dx, dy, this.opponentColor)) continue;

                        opponentMoveCount++;
                        if (opponentMoveCount > maxOpponentMoves) break;

                        let opponentScore = 0;

                        // è¯„ä¼°å¯¹æ–¹çš„è¿™ä¸€æ­¥
                        if (this.checkCaptureOnBoard(tempBoard, dx, dy, this.opponentColor)) {
                            opponentScore += 100; // å¯¹æ–¹èƒ½æå­ï¼Œå¯¹æˆ‘ä»¬ä¸åˆ©
                        }

                        if (this.checkAtariOnBoard(tempBoard, dx, dy, this.opponentColor, this.color)) {
                            opponentScore += 50; // å¯¹æ–¹èƒ½æ‰“åƒ
                        }

                        if (opponentScore > bestOpponentScore) {
                            bestOpponentScore = opponentScore;
                        }
                    }

                    if (opponentMoveCount > maxOpponentMoves) break;
                }

                // è¿”å›å·±æ–¹å¾—åˆ†å‡å»å¯¹æ–¹æœ€ä½³å¾—åˆ†
                return -bestOpponentScore * 0.5;
            }

            checkCaptureOnBoard(board, x, y, color) {
                const tempBoard = board.clone();
                if (!tempBoard.placeStone(x, y, color)) return false;
                const captures = tempBoard.detectCaptures(x, y, color);
                return captures.length > 0;
            }

            checkAtariOnBoard(board, x, y, attackerColor, defenderColor) {
                const tempBoard = board.clone();
                if (!tempBoard.placeStone(x, y, attackerColor)) return false;

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                for (const n of neighbors) {
                    if (tempBoard.isOnBoard(n.x, n.y) && tempBoard.grid[n.y][n.x] === defenderColor) {
                        // ä½¿ç”¨æ–°çš„ getGroupLiberties å‡½æ•°
                        const result = tempBoard.getGroupLiberties(n.x, n.y);
                        if (result.liberties === 1) return true;
                    }
                }
                return false;
            }
        }

        // ==================== UIController ç±» ====================
        class UIController {
            constructor() {
                this.boardElement = document.getElementById('go-board');
                this.infoElements = {
                    currentPlayer: document.getElementById('current-player'),
                    blackCaptures: document.getElementById('black-captures'),
                    whiteCaptures: document.getElementById('white-captures'),
                    moveCount: document.getElementById('move-count'),
                    status: document.getElementById('status')
                };
                this.modal = document.getElementById('modal');
                this.modalElements = {
                    winner: document.getElementById('winner'),
                    details: document.getElementById('result-details')
                };

                this.cellSize = 45;
                this.padding = 20;

                this.initBoard();
            }

            // åˆå§‹åŒ–æ£‹ç›˜
            initBoard() {
                const boardSize = this.cellSize * (13 - 1) + this.padding * 2;
                this.boardElement.style.width = boardSize + 'px';
                this.boardElement.style.height = boardSize + 'px';
                this.boardElement.innerHTML = '';

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                for (let i = 0; i < 13; i++) {
                    const pos = this.padding + i * this.cellSize;

                    // æ°´å¹³çº¿
                    const hLine = document.createElement('div');
                    hLine.className = 'grid-line horizontal';
                    hLine.style.top = pos + 'px';
                    this.boardElement.appendChild(hLine);

                    // å‚ç›´çº¿
                    const vLine = document.createElement('div');
                    vLine.className = 'grid-line vertical';
                    vLine.style.left = pos + 'px';
                    this.boardElement.appendChild(vLine);
                }

                // ç»˜åˆ¶æ˜Ÿä½
                const starPoints = [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]];
                starPoints.forEach(([x, y]) => {
                    const star = document.createElement('div');
                    star.className = 'star-point';
                    star.style.left = (this.padding + x * this.cellSize) + 'px';
                    star.style.top = (this.padding + y * this.cellSize) + 'px';
                    this.boardElement.appendChild(star);
                });
            }

            // æ¸²æŸ“æ£‹ç›˜
            renderBoard(board) {
                // æ¸…é™¤æ‰€æœ‰æ£‹å­
                const existingStones = this.boardElement.querySelectorAll('.stone');
                existingStones.forEach(stone => stone.remove());

                // ç»˜åˆ¶æ‰€æœ‰æ£‹å­
                for (let y = 0; y < board.size; y++) {
                    for (let x = 0; x < board.size; x++) {
                        if (board.grid[y][x] !== EMPTY) {
                            this.createStoneElement(x, y, board.grid[y][x], false);
                        }
                    }
                }

                // æ ‡è®°æœ€åè½å­
                if (board.lastMove) {
                    const lastStone = this.getStoneAt(board.lastMove.x, board.lastMove.y);
                    if (lastStone) {
                        lastStone.classList.add('last-move');
                    }
                }
            }

            // åˆ›å»ºæ£‹å­å…ƒç´ 
            createStoneElement(x, y, color, isLastMove = false) {
                const stone = document.createElement('div');
                stone.className = `stone ${color === BLACK ? 'black' : 'white'}`;
                stone.style.left = (this.padding + x * this.cellSize) + 'px';
                stone.style.top = (this.padding + y * this.cellSize) + 'px';
                stone.style.width = (this.cellSize - 4) + 'px';
                stone.style.height = (this.cellSize - 4) + 'px';
                stone.dataset.x = x;
                stone.dataset.y = y;

                if (isLastMove) {
                    stone.classList.add('last-move');
                }

                this.boardElement.appendChild(stone);
                return stone;
            }

            // è·å–æŒ‡å®šä½ç½®çš„æ£‹å­å…ƒç´ 
            getStoneAt(x, y) {
                return this.boardElement.querySelector(`.stone[data-x="${x}"][data-y="${y}"]`);
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatus(board, currentPlayer) {
                this.infoElements.currentPlayer.textContent =
                    currentPlayer === BLACK ? 'é»‘æ–¹ (ç©å®¶)' : 'ç™½æ–¹ (AI)';
                this.infoElements.blackCaptures.textContent = board.captures.black;
                this.infoElements.whiteCaptures.textContent = board.captures.white;
                this.infoElements.moveCount.textContent = board.history.length;
            }

            // æ˜¾ç¤ºæ¶ˆæ¯
            showMessage(message) {
                this.infoElements.status.textContent = message;
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
            showGameOver(result) {
                const winnerText = result.winner === BLACK ? 'é»‘æ–¹è·èƒœï¼' : 'ç™½æ–¹è·èƒœï¼';
                this.modalElements.winner.textContent = winnerText;

                const details = `
                    é»‘æ–¹: ${result.blackScore} ç‚¹ (æå­ ${result.captures.black})<br>
                    ç™½æ–¹: ${result.whiteScore} ç‚¹ (æå­ ${result.captures.white})
                `;
                this.modalElements.details.innerHTML = details;

                this.modal.classList.add('active');
            }

            // éšè—æ¨¡æ€æ¡†
            hideModal() {
                this.modal.classList.remove('active');
            }

            // è·å–ç‚¹å‡»åæ ‡
            getClickPosition(event) {
                const rect = this.boardElement.getBoundingClientRect();
                const x = Math.round((event.clientX - rect.left - this.padding) / this.cellSize);
                const y = Math.round((event.clientY - rect.top - this.padding) / this.cellSize);

                // ç¡®ä¿åæ ‡åœ¨æ£‹ç›˜èŒƒå›´å†… (0-12)
                return {
                    x: Math.max(0, Math.min(12, x)),
                    y: Math.max(0, Math.min(12, y))
                };
            }
        }

        // ==================== GameController ç±» ====================
        class GameController {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, difficulty);
                this.ui = new UIController();
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';

                this.setupEventListeners();
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            getDifficultyName() {
                const names = {
                    'easy': 'ç®€å• ğŸ˜Š',
                    'medium': 'ä¸­ç­‰ ğŸ¤”',
                    'hard': 'å›°éš¾ ğŸ˜ˆ'
                };
                return names[this.difficulty] || this.difficulty;
            }

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners() {
                // ä½¿ç”¨å…¨å±€è¾…åŠ©å‡½æ•°æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤æ·»åŠ 
                registerEventListener(this.ui.boardElement, 'click', (e) => this.handleBoardClick(e));

                registerEventListener(document.getElementById('restart-btn'), 'click', () => this.restart());
                registerEventListener(document.getElementById('undo-btn'), 'click', () => this.handleUndo());
                registerEventListener(document.getElementById('home-btn'), 'click', () => this.backToDifficultySelect());
                registerEventListener(document.getElementById('modal-restart'), 'click', () => {
                    this.ui.hideModal();
                    this.restart();
                });
                registerEventListener(document.getElementById('modal-home'), 'click', () => {
                    this.ui.hideModal();
                    this.backToDifficultySelect();
                });
            }

            // å¤„ç†æ£‹ç›˜ç‚¹å‡»
            handleBoardClick(event) {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== BLACK) {
                    return;
                }

                const { x, y } = this.ui.getClickPosition(event);

                if (this.board.placeStone(x, y, BLACK)) {
                    this.ui.renderBoard(this.board);
                    this.ui.updateStatus(this.board, this.currentPlayer);

                    // åˆ‡æ¢åˆ° AI
                    this.currentPlayer = WHITE;
                    this.ui.updateStatus(this.board, this.currentPlayer);
                    this.ui.showMessage('AI æ€è€ƒä¸­...');

                    setTimeout(() => this.handleAIMove(), 500);
                } else {
                    this.ui.showMessage('æ— æ•ˆçš„è½å­ä½ç½®');
                }
            }

            // å¤„ç† AI è½å­
            handleAIMove() {
                console.log(`\n========== AI å›åˆå¼€å§‹ ==========`);
                console.log(`å½“å‰æ¸¸æˆé˜¶æ®µ: ${this.gamePhase}`);

                if (this.gamePhase !== 'playing') {
                    console.log(`âŒ æ¸¸æˆæœªåœ¨è¿›è¡Œä¸­ï¼Œé€€å‡º`);
                    return;
                }

                const move = this.ai.selectMove();

                if (move) {
                    console.log(`\nğŸ“ å°è¯•åœ¨ (${move.x}, ${move.y}) è½å­...`);

                    // æ£€æŸ¥è½å­æ˜¯å¦æˆåŠŸ
                    if (this.board.placeStone(move.x, move.y, WHITE)) {
                        console.log(`âœ… è½å­æˆåŠŸï¼`);
                        console.log(`   å½“å‰æ£‹ç›˜çŠ¶æ€: æ‰‹æ•°=${this.board.history.length}, é»‘æ=${this.board.captures.black}, ç™½æ=${this.board.captures.white}`);
                        this.ui.renderBoard(this.board);
                        this.ui.showMessage('AI è½å­å®Œæˆ');
                    } else {
                        // å¦‚æœè½å­å¤±è´¥ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºAIå·²ç»éªŒè¯è¿‡ï¼‰
                        console.log(`âŒ è½å­å¤±è´¥ï¼ä½ç½® (${move.x}, ${move.y}) æ— æ•ˆ`);
                        console.log(`   å¯èƒ½åŸå› ï¼šæ‰“åŠ«ã€è‡ªæ€ã€æˆ–ä½ç½®å·²è¢«å ç”¨`);
                        console.log(`   AIå°†å°è¯•å…¶ä»–ä½ç½®...`);
                        // ç”±äºAIå·²ç»éªŒè¯è¿‡ä½ç½®ï¼Œç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™é‡Œ
                        // å¦‚æœåˆ°äº†è¿™é‡Œï¼Œè¯´æ˜æœ‰bugï¼Œä½†æˆ‘ä»¬ç»§ç»­è®©AIå°è¯•è½å­
                        return;
                    }
                } else {
                    console.log(`âš ï¸ AIæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®`);
                    console.log(`   å¯èƒ½æ£‹ç›˜å·²æ»¡æˆ–å…¨éƒ¨è¢«å°é”`);
                    this.ui.showMessage('AIæ— æ³•è½å­ï¼Œæ¸¸æˆç»“æŸ');
                    this.endGame();
                    return;
                }

                this.currentPlayer = BLACK;
                this.ui.updateStatus(this.board, this.currentPlayer);
                console.log(`========== AI å›åˆç»“æŸ ==========\n`);
            }

            // å¤„ç†æ‚”æ£‹
            handleUndo() {
                if (this.gamePhase !== 'playing') return;

                // æ’¤é”€ AI çš„è½å­
                if (this.board.undo()) {
                    // æ’¤é”€ç©å®¶çš„è½å­
                    if (this.board.undo()) {
                        this.currentPlayer = BLACK;
                        this.ui.renderBoard(this.board);
                        this.ui.updateStatus(this.board, this.currentPlayer);
                        this.ui.showMessage('æ‚”æ£‹æˆåŠŸ');
                    } else {
                        // æ¢å¤ AI çš„è½å­
                        this.board.placeStone(
                            this.board.history[this.board.history.length - 1].x,
                            this.board.history[this.board.history.length - 1].y,
                            WHITE
                        );
                        this.ui.showMessage('æ— æ³•æ‚”æ£‹');
                    }
                } else {
                    this.ui.showMessage('æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ­¥æ•°');
                }
            }

            // ç»“æŸæ¸¸æˆ
            endGame() {
                this.gamePhase = 'finished';

                const territory = this.board.countTerritory();
                const blackScore = territory.black + this.board.captures.black;
                const whiteScore = territory.white + this.board.captures.white + 6.5; // è´´ç›®

                const result = {
                    winner: blackScore > whiteScore ? BLACK : WHITE,
                    blackScore,
                    whiteScore,
                    captures: this.board.captures
                };

                this.ui.showGameOver(result);
            }

            // é‡æ–°å¼€å§‹
            restart() {
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, this.difficulty);
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';

                this.ui.initBoard();
                this.ui.renderBoard(this.board);
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            // è¿”å›éš¾åº¦é€‰æ‹©
            backToDifficultySelect() {
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('difficulty-modal').classList.remove('hidden');
            }
        }

        // ==================== å…¨å±€æ¸¸æˆå®ä¾‹å’Œå¼€å§‹å‡½æ•° ====================
        let game = null;
        let eventListeners = [];

        function startGame(difficulty) {
            // éšè—éš¾åº¦é€‰æ‹©ç•Œé¢
            document.getElementById('difficulty-modal').classList.add('hidden');

            // æ˜¾ç¤ºæ¸¸æˆå®¹å™¨
            document.getElementById('game-container').style.display = 'block';

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            eventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            eventListeners = [];

            // åˆ›å»ºæ¸¸æˆå®ä¾‹
            game = new GameController(difficulty);
        }

        // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨çš„è¾…åŠ©å‡½æ•°
        function registerEventListener(element, event, handler) {
            // ç§»é™¤å·²å­˜åœ¨çš„ç›¸åŒç›‘å¬å™¨ï¼ˆå¦‚æœæœ‰ï¼‰
            eventListeners = eventListeners.filter(listener => {
                if (listener.element === element && listener.event === event) {
                    listener.element.removeEventListener(listener.event, listener.handler);
                    return false;
                }
                return true;
            });

            // æ·»åŠ æ–°ç›‘å¬å™¨
            element.addEventListener(event, handler);
            eventListeners.push({ element, event, handler });
        }

        // ==================== åˆå§‹åŒ–æ¸¸æˆ ====================
        // é¡µé¢åŠ è½½æ—¶ä¸è‡ªåŠ¨åˆå§‹åŒ–ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©éš¾åº¦
    </script>
</body>
</html>