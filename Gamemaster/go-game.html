<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›´æ£‹ - äººæœºå¯¹æˆ˜</title>
    <style>
        /* ==================== CSS Variables ==================== */
        :root {
            /* æµ…è‰²æ¨¡å¼é…è‰² */
            --bg-primary: #F5F5F7;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #E8E8ED;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --text-tertiary: #C7C7CC;
            --system-blue: #007AFF;
            --system-blue-hover: #0051D5;
            --system-blue-active: #004FC4;

            /* è¯­ä¹‰é…è‰² */
            --success-green: #34C759;
            --warning-orange: #FF9500;
            --danger-red: #FF3B30;
        }

        /* ==================== Global Styles ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display',
                         'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: var(--text-primary);
        }

        #game-container {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            border-radius: 24px;
            padding: 40px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 32px rgba(0, 0, 0, 0.08);
            max-width: 920px;
            width: 100%;
            animation: pageTransition 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes pageTransition {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 32px;
            font-size: 40px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        /* ==================== Game Info Cards ==================== */
        .game-info {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 32px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 20px;
        }

        .info-item {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .info-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
        }

        .info-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            font-feature-settings: 'tnum';
        }

        /* ==================== Board ==================== */
        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 32px;
        }

        #go-board {
            position: relative;
            background: linear-gradient(135deg, #E8C969 0%, #D4AF37 50%, #C9A227 100%);
            background-image:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.02) 2px,
                    rgba(0, 0, 0, 0.02) 4px
                );
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.12),
                0 24px 48px rgba(0, 0, 0, 0.16),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            cursor: pointer;
            user-select: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
        }

        .grid-line.horizontal {
            height: 1px;
            left: 20px;
            right: 20px;
        }

        .grid-line.vertical {
            width: 1px;
            top: 20px;
            bottom: 20px;
        }

        .star-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .stone {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s cubic-bezier(0.25, 0.1, 0.25, 1);
            cursor: default;
            animation: stonePlace 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes stonePlace {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .stone.black {
            background: radial-gradient(circle at 35% 35%, #4A4A4A 0%, #1D1D1F 40%, #000000 100%);
            box-shadow:
                0 0 0 1px rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 8px 16px rgba(0, 0, 0, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .stone.white {
            background: radial-gradient(circle at 35% 35%, #FFFFFF 0%, #F5F5F7 40%, #E8E8ED 100%);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.2),
                0 8px 16px rgba(0, 0, 0, 0.15),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: var(--system-blue);
            border-radius: 50%;
            box-shadow:
                0 0 0 3px rgba(0, 122, 255, 0.3),
                0 0 12px rgba(0, 122, 255, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow:
                    0 0 0 3px rgba(0, 122, 255, 0.3),
                    0 0 12px rgba(0, 122, 255, 0.5);
            }
            50% {
                box-shadow:
                    0 0 0 5px rgba(0, 122, 255, 0.2),
                    0 0 20px rgba(0, 122, 255, 0.4);
            }
        }

        /* ==================== Controls ==================== */
        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 24px;
            font-size: 17px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: var(--system-blue);
            color: white;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        button:hover {
            background: var(--system-blue-hover);
            transform: translateY(-1px);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        button:active {
            background: var(--system-blue-active);
            transform: scale(0.97);
            transition: transform 0.1s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        button:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: var(--text-tertiary);
            transform: none;
        }

        .status {
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: var(--text-secondary);
            min-height: 24px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .status.highlight {
            color: var(--system-blue);
            background: rgba(0, 122, 255, 0.1);
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ==================== Modal ==================== */
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            padding: 48px;
            border-radius: 24px;
            text-align: center;
            max-width: 480px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 32px rgba(0, 0, 0, 0.08);
            animation: slideUp 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(40px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-content h2 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--text-primary);
        }

        .result-details {
            margin: 24px 0;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .winner {
            font-size: 48px;
            font-weight: 800;
            margin: 24px 0;
            letter-spacing: -1px;
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 50%, #AF52DE 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 32px;
        }

        .modal-btn {
            padding: 16px 32px;
            font-size: 17px;
            font-weight: 600;
            background: var(--system-blue);
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .modal-btn:hover {
            background: var(--system-blue-hover);
            transform: translateY(-1px);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .modal-btn:active {
            transform: scale(0.97);
        }

        /* ==================== Difficulty Selection ==================== */
        #difficulty-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #difficulty-modal.hidden {
            display: none;
        }

        .difficulty-content {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            padding: 60px 50px;
            border-radius: 24px;
            text-align: center;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 4px 8px rgba(0, 0, 0, 0.04),
                0 16px 24px rgba(0, 0, 0, 0.06);
            animation: slideUp 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
            max-width: 540px;
            width: 90%;
        }

        .difficulty-content h1 {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 50%, #AF52DE 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .difficulty-content h2 {
            font-size: 28px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 48px;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .difficulty-btn {
            padding: 18px 28px;
            font-size: 17px;
            font-weight: 600;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.04),
                0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            color: var(--text-primary);
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .difficulty-btn:hover {
            transform: scale(1.02);
            box-shadow:
                0 0 0 1px rgba(0, 0, 0, 0.08),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .difficulty-btn:active {
            transform: scale(0.98);
            transition: transform 0.1s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.08) 100%);
            border: 1px solid rgba(52, 199, 89, 0.3);
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, rgba(255, 149, 0, 0.15) 0%, rgba(255, 149, 0, 0.08) 100%);
            border: 1px solid rgba(255, 149, 0, 0.3);
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.08) 100%);
            border: 1px solid rgba(255, 59, 48, 0.3);
        }

        .difficulty-description {
            margin-top: 4px;
            font-size: 14px;
            font-weight: 400;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        /* ==================== Responsive Design ==================== */
        @media (max-width: 768px) {
            #game-container {
                padding: 24px 16px;
                margin: 16px;
                border-radius: 20px;
            }

            h1 {
                font-size: 28px;
                margin-bottom: 24px;
            }

            .game-info {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                padding: 16px;
            }

            .info-item {
                padding: 12px;
            }

            .info-label {
                font-size: 11px;
            }

            .info-value {
                font-size: 20px;
            }

            .board-container {
                margin: 0 -16px;
                padding: 0 16px;
                overflow: hidden;
            }

            #go-board {
                max-width: 100%;
                height: auto;
            }

            .controls {
                gap: 8px;
            }

            button {
                padding: 12px 20px;
                font-size: 15px;
                flex: 1 1 calc(50% - 8px);
            }

            .modal-content {
                margin: 20px;
                padding: 32px 24px;
                border-radius: 20px;
            }

            .winner {
                font-size: 32px;
            }

            .difficulty-content {
                margin: 20px;
                padding: 40px 24px;
            }

            .difficulty-content h1 {
                font-size: 36px;
            }

            .difficulty-content h2 {
                font-size: 22px;
            }
        }

        @media (max-width: 375px) {
            .game-info {
                grid-template-columns: 1fr;
            }

            button {
                flex: 1 1 100%;
            }

            #go-board {
                border-radius: 12px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            #game-container {
                max-width: 700px;
                padding: 36px;
            }

            .game-info {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ==================== Accessibility ==================== */
        @media (prefers-contrast: high) {
            button {
                border: 2px solid currentColor;
            }

            .info-value {
                font-weight: 800;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .difficulty-btn {
                min-height: 48px;
                padding: 16px 24px;
            }
        }
    </style>
</head>
<body>
    <!-- éš¾åº¦é€‰æ‹©ç•Œé¢ -->
    <div id="difficulty-modal">
        <div class="difficulty-content">
            <h1>å›´æ£‹å¤§å¸ˆ</h1>
            <h2>é€‰æ‹©éš¾åº¦</h2>
            <div class="difficulty-buttons">
                <button class="difficulty-btn easy" onclick="startGame('easy')">
                    ç®€å•
                    <div class="difficulty-description">éšæœºè½å­ï¼Œé€‚åˆåˆå­¦è€…</div>
                </button>
                <button class="difficulty-btn medium" onclick="startGame('medium')">
                    ä¸­ç­‰
                    <div class="difficulty-description">ä¼šæå­å’Œé˜²å®ˆï¼Œæœ‰åŸºæœ¬ç­–ç•¥</div>
                </button>
                <button class="difficulty-btn hard" onclick="startGame('hard')">
                    å›°éš¾
                    <div class="difficulty-description">é«˜çº§ç­–ç•¥ï¼Œå–„äºåˆ‡æ–­å’Œå›´åœ°</div>
                </button>
            </div>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <h1>å›´æ£‹ äººæœºå¯¹æˆ˜</h1>

        <div class="game-info">
            <div class="info-item">
                <div class="info-label">å½“å‰å›åˆ</div>
                <div class="info-value" id="current-player">é»‘æ–¹ (ç©å®¶)</div>
            </div>
            <div class="info-item">
                <div class="info-label">é»‘æ–¹æå­</div>
                <div class="info-value" id="black-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">ç™½æ–¹æå­</div>
                <div class="info-value" id="white-captures">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">æ‰‹æ•°</div>
                <div class="info-value" id="move-count">0</div>
            </div>
        </div>

        <div class="board-container">
            <div id="go-board"></div>
        </div>

        <div class="controls">
            <button id="undo-btn">æ‚”æ£‹</button>
            <button id="restart-btn">é‡æ–°å¼€å§‹</button>
            <button id="home-btn">è¿”å›ä¸»é¡µ</button>
        </div>

        <div class="status" id="status">ç‚¹å‡»æ£‹ç›˜è½å­ï¼Œé»‘æ–¹å…ˆè¡Œ</div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <div class="winner" id="winner"></div>
            <div class="result-details" id="result-details"></div>
            <div class="modal-buttons">
                <button class="modal-btn" id="modal-restart">å†æ¥ä¸€å±€</button>
                <button class="modal-btn" id="modal-home">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== å¸¸é‡å®šä¹‰ ====================
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        // ==================== GoBoard ç±» ====================
        class GoBoard {
            constructor(size = 13) {
                this.size = size;
                this.grid = Array(size).fill(null).map(() => Array(size).fill(EMPTY));
                this.koPoint = null;
                this.history = [];
                this.captures = { black: 0, white: 0 };
                this.lastMove = null;
            }

            // å¤åˆ¶æ£‹ç›˜
            clone() {
                const newBoard = new GoBoard(this.size);
                newBoard.grid = this.grid.map(row => [...row]);
                newBoard.koPoint = this.koPoint ? { ...this.koPoint } : null;
                newBoard.history = [...this.history];
                newBoard.captures = { ...this.captures };
                newBoard.lastMove = this.lastMove ? { ...this.lastMove } : null;
                return newBoard;
            }

            // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨æ£‹ç›˜å†…
            isOnBoard(x, y) {
                return x >= 0 && x < this.size && y >= 0 && y < this.size;
            }

            // è·å–æ£‹å­ç»„ï¼ˆæ³›æ´ªç®—æ³•ï¼‰
            getGroup(startX, startY) {
                const color = this.grid[startY][startX];
                if (color === EMPTY) return [];

                const group = [];
                const visited = new Set();
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (this.grid[y][x] === color) {
                        group.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];

                        neighbors.forEach(n => {
                            if (this.isOnBoard(n.x, n.y) && !visited.has(`${n.x},${n.y}`)) {
                                stack.push(n);
                            }
                        });
                    }
                }

                return group;
            }

            // è®¡ç®—æ°”æ•°
            getLiberties(group) {
                const liberties = new Set();

                group.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === EMPTY) {
                            liberties.add(`${n.x},${n.y}`);
                        }
                    });
                });

                return liberties.size;
            }

            // æ£€æµ‹æå­
            detectCaptures(x, y, placedColor) {
                const opponentColor = placedColor === BLACK ? WHITE : BLACK;
                const captured = [];

                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                neighbors.forEach(n => {
                    if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === opponentColor) {
                        const group = this.getGroup(n.x, n.y);
                        const liberties = this.getLiberties(group);

                        if (liberties === 0) {
                            group.forEach(stone => {
                                if (!captured.some(c => c.x === stone.x && c.y === stone.y)) {
                                    captured.push(stone);
                                }
                            });
                        }
                    }
                });

                return captured;
            }

            // ç§»é™¤æ£‹å­ç»„
            removeGroup(group) {
                group.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });
            }

            // è·å–æ£‹ç›˜å“ˆå¸Œå€¼ï¼ˆç”¨äºæ‰“åŠ«æ£€æµ‹ï¼‰
            getBoardHash() {
                return this.grid.map(row => row.join('')).join('|');
            }

            // è½å­
            placeStone(x, y, color) {
                const colorName = color === BLACK ? 'é»‘' : 'ç™½';
                const debug = color === WHITE; // åªä¸ºç™½æ£‹ï¼ˆAIï¼‰æ‰“å°è¯¦ç»†æ—¥å¿—

                if (debug) console.log(`   [è½å­éªŒè¯] å°è¯•${colorName}æ£‹åœ¨ (${x}, ${y})`);

                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    if (debug) console.log(`   [è½å­éªŒè¯] âŒ ä½ç½®æ— æ•ˆæˆ–å·²è¢«å ç”¨`);
                    return false;
                }

                // æ”¾ç½®æ£‹å­
                this.grid[y][x] = color;

                // æ£€æŸ¥æå­ï¼ˆåœ¨è½å­åï¼‰
                const captured = this.detectCaptures(x, y, color);
                if (debug && captured.length > 0) {
                    console.log(`   [è½å­éªŒè¯] ğŸ¯ å¯æ ${captured.length} å­: ${captured.map(c => `(${c.x},${c.y})`).join(', ')}`);
                }

                // æ£€æŸ¥è‡ªæ€ï¼ˆå¦‚æœæ²¡æœ‰æå­ä¸”è‡ªå·±ä¹Ÿæ²¡æ°”äº†ï¼‰
                if (captured.length === 0) {
                    const group = this.getGroup(x, y);
                    const liberties = this.getLiberties(group);
                    if (debug) console.log(`   [è½å­éªŒè¯] æ£‹å­ç»„å¤§å°: ${group.length}, æ°”æ•°: ${liberties}`);

                    if (liberties === 0) {
                        // æ’¤é”€è½å­
                        this.grid[y][x] = EMPTY;
                        if (debug) console.log(`   [è½å­éªŒè¯] âŒ è‡ªæ€ä½ç½®ï¼Œæ‹’ç»`);
                        return false;
                    }
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    // æ’¤é”€è½å­å’Œæå­
                    this.grid[y][x] = EMPTY;
                    captured.forEach(stone => {
                        this.grid[stone.y][stone.x] = (color === BLACK ? WHITE : BLACK);
                    });
                    if (debug) console.log(`   [è½å­éªŒè¯] âŒ æ‰“åŠ«ä½ç½®ï¼Œæ‹’ç» (åŠ«ç‚¹: ${this.koPoint.x},${this.koPoint.y})`);
                    return false;
                }

                // ç§»é™¤è¢«æçš„å­
                captured.forEach(stone => {
                    this.grid[stone.y][stone.x] = EMPTY;
                });

                // æ›´æ–°æå­æ•°
                if (color === BLACK) {
                    this.captures.black += captured.length;
                } else {
                    this.captures.white += captured.length;
                }

                // æ›´æ–°æ‰“åŠ«ç‚¹
                if (captured.length === 1) {
                    const opponentsGroups = [];
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] === (color === BLACK ? WHITE : BLACK)) {
                            opponentsGroups.push(this.getGroup(n.x, n.y));
                        }
                    });

                    const ownGroup = this.getGroup(x, y);
                    if (ownGroup.length === 1 && this.getLiberties(ownGroup) === 1 && opponentsGroups.some(g => g.length === 1)) {
                        this.koPoint = captured[0];
                        if (debug) console.log(`   [è½å­éªŒè¯] âš ï¸ æ‰“åŠ«å‘ç”Ÿï¼ŒåŠ«ç‚¹è®¾ç½®ä¸º (${this.koPoint.x},${this.koPoint.y})`);
                    } else {
                        this.koPoint = null;
                    }
                } else {
                    this.koPoint = null;
                }

                // è®°å½•å†å²
                this.history.push({
                    x, y, color,
                    captures: captured,
                    boardHash: this.getBoardHash()
                });

                this.lastMove = { x, y };

                if (debug) console.log(`   [è½å­éªŒè¯] âœ… è½å­æˆåŠŸ`);
                return true;
            }

            // éªŒè¯è½å­æ˜¯å¦åˆæ³•
            isValidMove(x, y, color) {
                // æ£€æŸ¥ä½ç½®æ˜¯å¦ä¸ºç©º
                if (!this.isOnBoard(x, y) || this.grid[y][x] !== EMPTY) {
                    return false;
                }

                // æ£€æŸ¥æ‰“åŠ«
                if (this.koPoint && x === this.koPoint.x && y === this.koPoint.y) {
                    return false;
                }

                // æ£€æŸ¥è‡ªæ€
                const tempBoard = this.clone();
                tempBoard.grid[y][x] = color;
                const captures = tempBoard.detectCaptures(x, y, color);

                if (captures.length === 0) {
                    const group = tempBoard.getGroup(x, y);
                    const liberties = tempBoard.getLiberties(group);
                    if (liberties === 0) {
                        return false;
                    }
                }

                return true;
            }

            // æ•°åœ°
            countTerritory() {
                const territory = { black: 0, white: 0 };
                const visited = new Set();

                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const key = `${x},${y}`;
                        if (this.grid[y][x] === EMPTY && !visited.has(key)) {
                            const region = this.getEmptyRegion(x, y, visited);
                            const owner = this.determineTerritoryOwner(region);

                            if (owner === BLACK) {
                                territory.black += region.length;
                            } else if (owner === WHITE) {
                                territory.white += region.length;
                            }
                        }
                    }
                }

                return territory;
            }

            // è·å–ç©ºåœ°åŒºåŸŸ
            getEmptyRegion(startX, startY, visited) {
                const region = [];
                const stack = [{ x: startX, y: startY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key) || !this.isOnBoard(x, y)) continue;

                    if (this.grid[y][x] === EMPTY) {
                        visited.add(key);
                        region.push({ x, y });

                        const neighbors = [
                            { x: x - 1, y }, { x: x + 1, y },
                            { x, y: y - 1 }, { x, y: y + 1 }
                        ];
                        neighbors.forEach(n => stack.push(n));
                    }
                }

                return region;
            }

            // åˆ¤æ–­åœ°åŸŸå½’å±
            determineTerritoryOwner(region) {
                const surroundingColors = new Set();

                region.forEach(stone => {
                    const { x, y } = stone;
                    const neighbors = [
                        { x: x - 1, y }, { x: x + 1, y },
                        { x, y: y - 1 }, { x, y: y + 1 }
                    ];

                    neighbors.forEach(n => {
                        if (this.isOnBoard(n.x, n.y) && this.grid[n.y][n.x] !== EMPTY) {
                            surroundingColors.add(this.grid[n.y][n.x]);
                        }
                    });
                });

                if (surroundingColors.size === 1) {
                    return surroundingColors.values().next().value;
                }

                return null;
            }

            // æ’¤é”€ä¸Šä¸€æ­¥
            undo() {
                if (this.history.length === 0) return false;

                const lastMove = this.history.pop();

                // æ¢å¤æ£‹ç›˜çŠ¶æ€
                this.grid[lastMove.y][lastMove.x] = EMPTY;

                // æ¢å¤è¢«æçš„å­
                const opponentColor = lastMove.color === BLACK ? WHITE : BLACK;
                lastMove.captures.forEach(stone => {
                    this.grid[stone.y][stone.x] = opponentColor;
                });

                // æ›´æ–°æå­æ•°
                if (lastMove.color === BLACK) {
                    this.captures.black -= lastMove.captures.length;
                } else {
                    this.captures.white -= lastMove.captures.length;
                }

                // æ›´æ–°æœ€åè½å­ä½ç½®
                this.lastMove = this.history.length > 0 ? {
                    x: this.history[this.history.length - 1].x,
                    y: this.history[this.history.length - 1].y
                } : null;

                return true;
            }
        }

        // ==================== GoAI ç±» ====================
        class GoAI {
            constructor(color, board, difficulty = 'medium') {
                this.color = color;
                this.board = board;
                this.difficulty = difficulty;
            }

            // é€‰æ‹©è½å­ï¼ˆæ ¹æ®éš¾åº¦ï¼‰
            selectMove() {
                console.log(`ğŸ¤– AIå¼€å§‹æ€è€ƒ... éš¾åº¦: ${this.difficulty}`);

                let move;
                switch (this.difficulty) {
                    case 'easy':
                        move = this.selectMoveEasy();
                        break;
                    case 'medium':
                        move = this.selectMoveMedium();
                        break;
                    case 'hard':
                        move = this.selectMoveHard();
                        break;
                    default:
                        move = this.selectMoveMedium();
                }

                if (move) {
                    console.log(`âœ… AIå†³å®šè½å­äº: (${move.x}, ${move.y})`);
                } else {
                    console.log(`âš ï¸ AIæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è½å­ä½ç½®ï¼Œé€‰æ‹©åœç€`);
                }

                return move;
            }

            // ==================== ç®€å•éš¾åº¦ ====================
            selectMoveEasy() {
                console.log(`   [ç®€å•æ¨¡å¼] å¼€å§‹æœç´¢å€™é€‰ä½ç½®...`);
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆä¸”ä¸ºç©º
                        if (this.board.isValidMove(x, y, this.color)) {
                            // ç®€å•AIï¼šåªè€ƒè™‘æœ‰ç›¸é‚»æ£‹å­æˆ–æ˜Ÿä½çš„ä½ç½®
                            if (this.hasNeighborStone(x, y) || this.isStarPoint(x, y)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }

                console.log(`   [ç®€å•æ¨¡å¼] æ‰¾åˆ° ${candidates.length} ä¸ªæœ‰é‚»å±…/æ˜Ÿä½çš„å€™é€‰ä½ç½®`);

                if (candidates.length === 0) {
                    // å¦‚æœæ²¡æœ‰å€™é€‰ç‚¹ï¼Œéšæœºé€‰æ‹©æœ‰æ•ˆç©ºä½
                    console.log(`   [ç®€å•æ¨¡å¼] æ²¡æœ‰æ‰¾åˆ°ç†æƒ³ä½ç½®ï¼Œæœç´¢æ‰€æœ‰æœ‰æ•ˆç©ºä½...`);
                    for (let y = 0; y < this.board.size; y++) {
                        for (let x = 0; x < this.board.size; x++) {
                            if (this.board.isValidMove(x, y, this.color)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                    console.log(`   [ç®€å•æ¨¡å¼] æ‰¾åˆ° ${candidates.length} ä¸ªæœ‰æ•ˆç©ºä½`);
                }

                if (candidates.length > 0) {
                    const randomIndex = Math.floor(Math.random() * candidates.length);
                    const selected = candidates[randomIndex];
                    console.log(`   [ç®€å•æ¨¡å¼] éšæœºé€‰æ‹©ç¬¬ ${randomIndex + 1}/${candidates.length} ä¸ªä½ç½®`);
                    return selected;
                }

                console.log(`   [ç®€å•æ¨¡å¼] âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                return null;
            }

            // ==================== ä¸­ç­‰éš¾åº¦ ====================
            selectMoveMedium() {
                console.log(`   [ä¸­ç­‰æ¨¡å¼] å¼€å§‹å†³ç­–...`);

                // ä¼˜å…ˆçº§1: å¯»æ‰¾æå­æœºä¼š
                const captureMoves = this.findCaptureMoves();
                if (captureMoves.length > 0) {
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] ğŸ¯ å‘ç°æå­æœºä¼š: ${captureMoves.length} ä¸ªï¼Œé€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜çš„`);
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] é€‰æ‹©ä½ç½®: (${captureMoves[0].x}, ${captureMoves[0].y}), å¯æ ${captureMoves[0].priority} å­`);
                    return captureMoves[0];
                }
                console.log(`   [ä¸­ç­‰æ¨¡å¼] æ²¡æœ‰æå­æœºä¼š`);

                // ä¼˜å…ˆçº§2: å¯»æ‰¾é˜²å®ˆæœºä¼š
                const defenseMoves = this.findDefenseMoves();
                if (defenseMoves.length > 0) {
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] ğŸ›¡ï¸ å‘ç°é˜²å®ˆæœºä¼š: ${defenseMoves.length} ä¸ª`);
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] é€‰æ‹©ä½ç½®: (${defenseMoves[0].x}, ${defenseMoves[0].y})`);
                    return defenseMoves[0];
                }
                console.log(`   [ä¸­ç­‰æ¨¡å¼] æ²¡æœ‰é˜²å®ˆæœºä¼š`);

                // ä¼˜å…ˆçº§3: ä½ç½®è¯„ä¼°
                const candidates = this.getCandidateMoves();
                if (candidates.length > 0) {
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] ğŸ“Š è¯„ä¼° ${candidates.length} ä¸ªå€™é€‰ä½ç½®...`);
                    const best = this.evaluateAndSelectBest(candidates);
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] æœ€ä½³ä½ç½®: (${best.x}, ${best.y}), å¾—åˆ†: ${best.score.toFixed(2)}`);
                    return best;
                }
                console.log(`   [ä¸­ç­‰æ¨¡å¼] æ²¡æœ‰ç†æƒ³å€™é€‰ä½ç½®`);

                // ä¼˜å…ˆçº§4: å¯»æ‰¾ä»»æ„æœ‰æ•ˆä½ç½®ï¼ˆä¿åº•ç­–ç•¥ï¼‰
                console.log(`   [ä¸­ç­‰æ¨¡å¼] ğŸ” æœç´¢ä»»æ„æœ‰æ•ˆä½ç½®ä½œä¸ºä¿åº•...`);
                const anyValid = this.findAnyValidMove();
                if (anyValid) {
                    console.log(`   [ä¸­ç­‰æ¨¡å¼] âœ… æ‰¾åˆ°ä¿åº•ä½ç½®: (${anyValid.x}, ${anyValid.y})`);
                    return anyValid;
                }

                console.log(`   [ä¸­ç­‰æ¨¡å¼] âŒ çœŸçš„æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                return null;
            }

            // ==================== å›°éš¾éš¾åº¦ ====================
            selectMoveHard() {
                console.log(`   [å›°éš¾æ¨¡å¼] å¼€å§‹æ·±åº¦åˆ†æ...`);

                // ä¼˜å…ˆçº§1: å¯»æ‰¾æå­æœºä¼šï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰
                const captureMoves = this.findCaptureMoves();
                if (captureMoves.length > 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] ğŸ¯ å‘ç°æå­æœºä¼š: ${captureMoves.length} ä¸ª`);
                    console.log(`   [å›°éš¾æ¨¡å¼] é€‰æ‹©ä½ç½®: (${captureMoves[0].x}, ${captureMoves[0].y}), å¯æ ${captureMoves[0].priority} å­`);
                    return captureMoves[0];
                }
                console.log(`   [å›°éš¾æ¨¡å¼] æ²¡æœ‰æå­æœºä¼š`);

                // ä¼˜å…ˆçº§2: å¯»æ‰¾åˆ‡æ–­æœºä¼šï¼ˆæ–°å¢ï¼‰
                const cutMoves = this.findCutMoves();
                if (cutMoves.length > 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] âœ‚ï¸ å‘ç°åˆ‡æ–­æœºä¼š: ${cutMoves.length} ä¸ª`);
                    console.log(`   [å›°éš¾æ¨¡å¼] é€‰æ‹©ä½ç½®: (${cutMoves[0].x}, ${cutMoves[0].y}), å¯åˆ‡æ–­ ${cutMoves[0].priority} ç»„`);
                    return cutMoves[0];
                }
                console.log(`   [å›°éš¾æ¨¡å¼] æ²¡æœ‰åˆ‡æ–­æœºä¼š`);

                // ä¼˜å…ˆçº§3: å¯»æ‰¾é˜²å®ˆæœºä¼š
                const defenseMoves = this.findDefenseMoves();
                if (defenseMoves.length > 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] ğŸ›¡ï¸ å‘ç°é˜²å®ˆæœºä¼š: ${defenseMoves.length} ä¸ª`);
                    console.log(`   [å›°éš¾æ¨¡å¼] é€‰æ‹©ä½ç½®: (${defenseMoves[0].x}, ${defenseMoves[0].y})`);
                    return defenseMoves[0];
                }
                console.log(`   [å›°éš¾æ¨¡å¼] æ²¡æœ‰é˜²å®ˆæœºä¼š`);

                // ä¼˜å…ˆçº§4: å¯»æ‰¾è¿›æ”»æœºä¼šï¼ˆå«åƒï¼‰
                const atariMoves = this.findAtariMoves();
                if (atariMoves.length > 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] âš”ï¸ å‘ç°å«åƒæœºä¼š: ${atariMoves.length} ä¸ª`);
                    console.log(`   [å›°éš¾æ¨¡å¼] é€‰æ‹©ä½ç½®: (${atariMoves[0].x}, ${atariMoves[0].y}), å¯å«åƒ ${atariMoves[0].priority} å­`);
                    return atariMoves[0];
                }
                console.log(`   [å›°éš¾æ¨¡å¼] æ²¡æœ‰å«åƒæœºä¼š`);

                // ä¼˜å…ˆçº§5: é«˜çº§ä½ç½®è¯„ä¼°
                const candidates = this.getCandidateMoves();
                if (candidates.length > 0) {
                    console.log(`   [å›°éš¾æ¨¡å¼] ğŸ“Š æ·±åº¦è¯„ä¼° ${candidates.length} ä¸ªå€™é€‰ä½ç½®...`);
                    const best = this.evaluateAndSelectBestAdvanced(candidates);
                    console.log(`   [å›°éš¾æ¨¡å¼] æœ€ä½³ä½ç½®: (${best.x}, ${best.y}), å¾—åˆ†: ${best.score.toFixed(2)}`);
                    return best;
                }
                console.log(`   [å›°éš¾æ¨¡å¼] æ²¡æœ‰ç†æƒ³å€™é€‰ä½ç½®`);

                // ä¼˜å…ˆçº§6: å¯»æ‰¾ä»»æ„æœ‰æ•ˆä½ç½®ï¼ˆä¿åº•ç­–ç•¥ï¼‰
                console.log(`   [å›°éš¾æ¨¡å¼] ğŸ” æœç´¢ä»»æ„æœ‰æ•ˆä½ç½®ä½œä¸ºä¿åº•...`);
                const anyValid = this.findAnyValidMove();
                if (anyValid) {
                    console.log(`   [å›°éš¾æ¨¡å¼] âœ… æ‰¾åˆ°ä¿åº•ä½ç½®: (${anyValid.x}, ${anyValid.y})`);
                    return anyValid;
                }

                console.log(`   [å›°éš¾æ¨¡å¼] âŒ çœŸçš„æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®ï¼`);
                return null;
            }

            // å¯»æ‰¾æå­æœºä¼š
            findCaptureMoves() {
                const moves = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.isOnBoard(x, y) && this.board.grid[y][x] === EMPTY) {
                            const tempBoard = this.board.clone();
                            if (tempBoard.placeStone(x, y, this.color)) {
                                const captures = tempBoard.detectCaptures(x, y, this.color);
                                if (captures.length > 0) {
                                    moves.push({ x, y, priority: captures.length });
                                }
                            }
                        }
                    }
                }

                return moves.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾é˜²å®ˆæœºä¼š
            findDefenseMoves() {
                const defenses = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === this.color) {
                            const group = this.board.getGroup(x, y);
                            const liberties = this.board.getLiberties(group);

                            if (liberties === 1) {
                                group.forEach(stone => {
                                    const neighbors = [
                                        { x: stone.x - 1, y: stone.y },
                                        { x: stone.x + 1, y: stone.y },
                                        { x: stone.x, y: stone.y - 1 },
                                        { x: stone.x, y: stone.y + 1 }
                                    ];

                                    neighbors.forEach(n => {
                                        if (this.board.isOnBoard(n.x, n.y) &&
                                            this.board.grid[n.y][n.x] === EMPTY) {
                                            if (!defenses.some(d => d.x === n.x && d.y === n.y)) {
                                                defenses.push({ x: n.x, y: n.y, priority: 10 });
                                            }
                                        }
                                    });
                                });
                            }
                        }
                    }
                }

                return defenses.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾åˆ‡æ–­æœºä¼šï¼ˆå›°éš¾æ¨¡å¼æ–°å¢ï¼‰
            findCutMoves() {
                const cuts = [];
                const opponentColor = this.color === BLACK ? WHITE : BLACK;

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            // æ£€æŸ¥è½å­åæ˜¯å¦èƒ½åˆ‡æ–­å¯¹æ–¹
                            const neighbors = [
                                { x: x - 1, y }, { x: x + 1, y },
                                { x, y: y - 1 }, { x, y: y + 1 }
                            ];

                            const opponentNeighbors = neighbors.filter(n =>
                                this.board.isOnBoard(n.x, n.y) &&
                                this.board.grid[n.y][n.x] === opponentColor
                            );

                            if (opponentNeighbors.length >= 2) {
                                // æ£€æŸ¥è¿™äº›å¯¹æ–¹æ£‹å­æ˜¯å¦å±äºä¸åŒç»„
                                const groups = opponentNeighbors.map(n => this.board.getGroup(n.x, n.y));
                                const uniqueGroups = [];
                                groups.forEach(g => {
                                    if (!uniqueGroups.some(ug => ug[0].x === g[0].x && ug[0].y === g[0].y)) {
                                        uniqueGroups.push(g);
                                    }
                                });

                                if (uniqueGroups.length >= 2) {
                                    cuts.push({ x, y, priority: uniqueGroups.length });
                                }
                            }
                        }
                    }
                }

                return cuts.sort((a, b) => b.priority - a.priority);
            }

            // å¯»æ‰¾å«åƒæœºä¼šï¼ˆå›°éš¾æ¨¡å¼æ–°å¢ï¼‰
            findAtariMoves() {
                const ataris = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        if (this.board.grid[y][x] === EMPTY) {
                            const tempBoard = this.board.clone();
                            if (tempBoard.placeStone(x, y, this.color)) {
                                const opponentColor = this.color === BLACK ? WHITE : BLACK;
                                const neighbors = [
                                    { x: x - 1, y }, { x: x + 1, y },
                                    { x, y: y - 1 }, { x, y: y + 1 }
                                ];

                                neighbors.forEach(n => {
                                    if (tempBoard.isOnBoard(n.x, n.y) &&
                                        tempBoard.grid[n.y][n.x] === opponentColor) {
                                        const group = tempBoard.getGroup(n.x, n.y);
                                        const liberties = tempBoard.getLiberties(group);

                                        if (liberties === 1) {
                                            if (!ataris.some(a => a.x === x && a.y === y)) {
                                                ataris.push({ x, y, priority: group.length });
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                return ataris.sort((a, b) => b.priority - a.priority);
            }

            // è·å–å€™é€‰è½å­ç‚¹
            getCandidateMoves() {
                const candidates = [];

                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                        if (this.board.isValidMove(x, y, this.color)) {
                            const hasNeighbor = this.hasNeighborStone(x, y);
                            if (hasNeighbor || this.isStarPoint(x, y)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }

                return candidates;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸é‚»æ£‹å­
            hasNeighborStone(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                return neighbors.some(n =>
                    this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] !== EMPTY
                );
            }

            // åˆ¤æ–­æ˜¯å¦ä¸ºæ˜Ÿä½
            isStarPoint(x, y) {
                const size = this.board.size;
                const starPoints = size === 13 ?
                    [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]] :
                    size === 19 ?
                    [[3, 3], [9, 3], [15, 3], [3, 9], [9, 9], [15, 9], [3, 15], [9, 15], [15, 15]] :
                    [];

                return starPoints.some(p => p[0] === x && p[1] === y);
            }

            // åŸºç¡€è¯„ä¼°ï¼ˆä¸­ç­‰éš¾åº¦ï¼‰
            evaluateAndSelectBest(candidates) {
                if (candidates.length === 0) return null;

                const scored = candidates.map(move => {
                    let score = 0;

                    const center = Math.floor(this.board.size / 2);
                    const distFromCenter = Math.abs(move.x - center) + Math.abs(move.y - center);
                    score += (this.board.size - distFromCenter);

                    if (this.isStarPoint(move.x, move.y)) {
                        score += 5;
                    }

                    if (this.hasNeighborStone(move.x, move.y)) {
                        score += 3;
                    }

                    score += Math.random() * 3;

                    return { ...move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                return scored[0];
            }

            // é«˜çº§è¯„ä¼°ï¼ˆå›°éš¾éš¾åº¦ï¼‰
            evaluateAndSelectBestAdvanced(candidates) {
                if (candidates.length === 0) return null;

                const scored = candidates.map(move => {
                    let score = 0;

                    // ä¸­å¿ƒä½ç½®åŠ åˆ†
                    const center = Math.floor(this.board.size / 2);
                    const distFromCenter = Math.abs(move.x - center) + Math.abs(move.y - center);
                    score += (this.board.size - distFromCenter) * 1.5;

                    // æ˜Ÿä½åŠ åˆ†æ›´é«˜
                    if (this.isStarPoint(move.x, move.y)) {
                        score += 8;
                    }

                    // ç›¸é‚»æ£‹å­åŠ åˆ†
                    if (this.hasNeighborStone(move.x, move.y)) {
                        const neighborCount = this.countNeighborStones(move.x, move.y);
                        score += neighborCount * 4;

                        // æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥è‡ªå·±çš„æ£‹å­
                        if (this.canConnectOwnStones(move.x, move.y)) {
                            score += 6;
                        }
                    }

                    // è¾¹ç¼˜ä½ç½®å‡åˆ†ï¼ˆé¿å…ä¸€è·¯ï¼‰
                    if (move.x === 0 || move.x === this.board.size - 1 ||
                        move.y === 0 || move.y === this.board.size - 1) {
                        score -= 3;
                    }

                    // äºŒè·¯ä½ç½®è½»å¾®å‡åˆ†
                    if (move.x === 1 || move.x === this.board.size - 2 ||
                        move.y === 1 || move.y === this.board.size - 2) {
                        score -= 1;
                    }

                    // æ·»åŠ å°‘é‡éšæœºæ€§
                    score += Math.random() * 2;

                    return { ...move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                return scored[0];
            }

            // è®¡ç®—ç›¸é‚»æ£‹å­æ•°é‡
            countNeighborStones(x, y) {
                let count = 0;
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                neighbors.forEach(n => {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] !== EMPTY) {
                        count++;
                    }
                });

                return count;
            }

            // æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥è‡ªå·±çš„æ£‹å­
            canConnectOwnStones(x, y) {
                const neighbors = [
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];

                let ownCount = 0;
                neighbors.forEach(n => {
                    if (this.board.isOnBoard(n.x, n.y) && this.board.grid[n.y][n.x] === this.color) {
                        ownCount++;
                    }
                });

                return ownCount >= 2;
            }

            // å¯»æ‰¾ä»»æ„æœ‰æ•ˆä½ç½®ï¼ˆä¿åº•ç­–ç•¥ï¼‰
            findAnyValidMove() {
                // ä¼˜å…ˆä»ä¸­å¿ƒå‘å¤–æœç´¢
                const center = Math.floor(this.board.size / 2);
                const positions = [];

                // æŒ‰ç…§è·ç¦»ä¸­å¿ƒçš„è¿œè¿‘æ’åºä½ç½®
                for (let y = 0; y < this.board.size; y++) {
                    for (let x = 0; x < this.board.size; x++) {
                        const distFromCenter = Math.abs(x - center) + Math.abs(y - center);
                        positions.push({ x, y, dist: distFromCenter });
                    }
                }

                // æŒ‰è·ç¦»æ’åºï¼Œä¼˜å…ˆé€‰æ‹©é è¿‘ä¸­å¿ƒçš„ä½ç½®
                positions.sort((a, b) => a.dist - b.dist);

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰æ•ˆä½ç½®
                for (const pos of positions) {
                    if (this.board.isValidMove(pos.x, pos.y, this.color)) {
                        return { x: pos.x, y: pos.y };
                    }
                }

                return null;
            }
        }

        // ==================== UIController ç±» ====================
        class UIController {
            constructor() {
                this.boardElement = document.getElementById('go-board');
                this.infoElements = {
                    currentPlayer: document.getElementById('current-player'),
                    blackCaptures: document.getElementById('black-captures'),
                    whiteCaptures: document.getElementById('white-captures'),
                    moveCount: document.getElementById('move-count'),
                    status: document.getElementById('status')
                };
                this.modal = document.getElementById('modal');
                this.modalElements = {
                    winner: document.getElementById('winner'),
                    details: document.getElementById('result-details')
                };

                this.cellSize = 45;
                this.padding = 20;

                this.initBoard();
            }

            // åˆå§‹åŒ–æ£‹ç›˜
            initBoard() {
                const boardSize = this.cellSize * (13 - 1) + this.padding * 2;
                this.boardElement.style.width = boardSize + 'px';
                this.boardElement.style.height = boardSize + 'px';
                this.boardElement.innerHTML = '';

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                for (let i = 0; i < 13; i++) {
                    const pos = this.padding + i * this.cellSize;

                    // æ°´å¹³çº¿
                    const hLine = document.createElement('div');
                    hLine.className = 'grid-line horizontal';
                    hLine.style.top = pos + 'px';
                    this.boardElement.appendChild(hLine);

                    // å‚ç›´çº¿
                    const vLine = document.createElement('div');
                    vLine.className = 'grid-line vertical';
                    vLine.style.left = pos + 'px';
                    this.boardElement.appendChild(vLine);
                }

                // ç»˜åˆ¶æ˜Ÿä½
                const starPoints = [[3, 3], [9, 3], [6, 6], [3, 9], [9, 9]];
                starPoints.forEach(([x, y]) => {
                    const star = document.createElement('div');
                    star.className = 'star-point';
                    star.style.left = (this.padding + x * this.cellSize) + 'px';
                    star.style.top = (this.padding + y * this.cellSize) + 'px';
                    this.boardElement.appendChild(star);
                });
            }

            // æ¸²æŸ“æ£‹ç›˜
            renderBoard(board) {
                // æ¸…é™¤æ‰€æœ‰æ£‹å­
                const existingStones = this.boardElement.querySelectorAll('.stone');
                existingStones.forEach(stone => stone.remove());

                // ç»˜åˆ¶æ‰€æœ‰æ£‹å­
                for (let y = 0; y < board.size; y++) {
                    for (let x = 0; x < board.size; x++) {
                        if (board.grid[y][x] !== EMPTY) {
                            this.createStoneElement(x, y, board.grid[y][x], false);
                        }
                    }
                }

                // æ ‡è®°æœ€åè½å­
                if (board.lastMove) {
                    const lastStone = this.getStoneAt(board.lastMove.x, board.lastMove.y);
                    if (lastStone) {
                        lastStone.classList.add('last-move');
                    }
                }
            }

            // åˆ›å»ºæ£‹å­å…ƒç´ 
            createStoneElement(x, y, color, isLastMove = false) {
                const stone = document.createElement('div');
                stone.className = `stone ${color === BLACK ? 'black' : 'white'}`;
                stone.style.left = (this.padding + x * this.cellSize) + 'px';
                stone.style.top = (this.padding + y * this.cellSize) + 'px';
                stone.style.width = (this.cellSize - 4) + 'px';
                stone.style.height = (this.cellSize - 4) + 'px';
                stone.dataset.x = x;
                stone.dataset.y = y;

                if (isLastMove) {
                    stone.classList.add('last-move');
                }

                this.boardElement.appendChild(stone);
                return stone;
            }

            // è·å–æŒ‡å®šä½ç½®çš„æ£‹å­å…ƒç´ 
            getStoneAt(x, y) {
                return this.boardElement.querySelector(`.stone[data-x="${x}"][data-y="${y}"]`);
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatus(board, currentPlayer) {
                this.infoElements.currentPlayer.textContent =
                    currentPlayer === BLACK ? 'é»‘æ–¹ (ç©å®¶)' : 'ç™½æ–¹ (AI)';
                this.infoElements.blackCaptures.textContent = board.captures.black;
                this.infoElements.whiteCaptures.textContent = board.captures.white;
                this.infoElements.moveCount.textContent = board.history.length;
            }

            // æ˜¾ç¤ºæ¶ˆæ¯
            showMessage(message) {
                this.infoElements.status.textContent = message;
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
            showGameOver(result) {
                const winnerText = result.winner === BLACK ? 'é»‘æ–¹è·èƒœï¼' : 'ç™½æ–¹è·èƒœï¼';
                this.modalElements.winner.textContent = winnerText;

                const details = `
                    é»‘æ–¹: ${result.blackScore} ç‚¹ (æå­ ${result.captures.black})<br>
                    ç™½æ–¹: ${result.whiteScore} ç‚¹ (æå­ ${result.captures.white})
                `;
                this.modalElements.details.innerHTML = details;

                this.modal.classList.add('active');
            }

            // éšè—æ¨¡æ€æ¡†
            hideModal() {
                this.modal.classList.remove('active');
            }

            // è·å–ç‚¹å‡»åæ ‡
            getClickPosition(event) {
                const rect = this.boardElement.getBoundingClientRect();
                const x = Math.round((event.clientX - rect.left - this.padding) / this.cellSize);
                const y = Math.round((event.clientY - rect.top - this.padding) / this.cellSize);

                // ç¡®ä¿åæ ‡åœ¨æ£‹ç›˜èŒƒå›´å†… (0-12)
                return {
                    x: Math.max(0, Math.min(12, x)),
                    y: Math.max(0, Math.min(12, y))
                };
            }
        }

        // ==================== GameController ç±» ====================
        class GameController {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, difficulty);
                this.ui = new UIController();
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';

                this.setupEventListeners();
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            getDifficultyName() {
                const names = {
                    'easy': 'ç®€å• ğŸ˜Š',
                    'medium': 'ä¸­ç­‰ ğŸ¤”',
                    'hard': 'å›°éš¾ ğŸ˜ˆ'
                };
                return names[this.difficulty] || this.difficulty;
            }

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners() {
                // ä½¿ç”¨å…¨å±€è¾…åŠ©å‡½æ•°æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤æ·»åŠ 
                registerEventListener(this.ui.boardElement, 'click', (e) => this.handleBoardClick(e));

                registerEventListener(document.getElementById('restart-btn'), 'click', () => this.restart());
                registerEventListener(document.getElementById('undo-btn'), 'click', () => this.handleUndo());
                registerEventListener(document.getElementById('home-btn'), 'click', () => this.backToDifficultySelect());
                registerEventListener(document.getElementById('modal-restart'), 'click', () => {
                    this.ui.hideModal();
                    this.restart();
                });
                registerEventListener(document.getElementById('modal-home'), 'click', () => {
                    this.ui.hideModal();
                    this.backToDifficultySelect();
                });
            }

            // å¤„ç†æ£‹ç›˜ç‚¹å‡»
            handleBoardClick(event) {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== BLACK) {
                    return;
                }

                const { x, y } = this.ui.getClickPosition(event);

                if (this.board.placeStone(x, y, BLACK)) {
                    this.ui.renderBoard(this.board);
                    this.ui.updateStatus(this.board, this.currentPlayer);

                    // åˆ‡æ¢åˆ° AI
                    this.currentPlayer = WHITE;
                    this.ui.updateStatus(this.board, this.currentPlayer);
                    this.ui.showMessage('AI æ€è€ƒä¸­...');

                    setTimeout(() => this.handleAIMove(), 500);
                } else {
                    this.ui.showMessage('æ— æ•ˆçš„è½å­ä½ç½®');
                }
            }

            // å¤„ç† AI è½å­
            handleAIMove() {
                console.log(`\n========== AI å›åˆå¼€å§‹ ==========`);
                console.log(`å½“å‰æ¸¸æˆé˜¶æ®µ: ${this.gamePhase}`);

                if (this.gamePhase !== 'playing') {
                    console.log(`âŒ æ¸¸æˆæœªåœ¨è¿›è¡Œä¸­ï¼Œé€€å‡º`);
                    return;
                }

                const move = this.ai.selectMove();

                if (move) {
                    console.log(`\nğŸ“ å°è¯•åœ¨ (${move.x}, ${move.y}) è½å­...`);

                    // æ£€æŸ¥è½å­æ˜¯å¦æˆåŠŸ
                    if (this.board.placeStone(move.x, move.y, WHITE)) {
                        console.log(`âœ… è½å­æˆåŠŸï¼`);
                        console.log(`   å½“å‰æ£‹ç›˜çŠ¶æ€: æ‰‹æ•°=${this.board.history.length}, é»‘æ=${this.board.captures.black}, ç™½æ=${this.board.captures.white}`);
                        this.ui.renderBoard(this.board);
                        this.ui.showMessage('AI è½å­å®Œæˆ');
                    } else {
                        // å¦‚æœè½å­å¤±è´¥ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºAIå·²ç»éªŒè¯è¿‡ï¼‰
                        console.log(`âŒ è½å­å¤±è´¥ï¼ä½ç½® (${move.x}, ${move.y}) æ— æ•ˆ`);
                        console.log(`   å¯èƒ½åŸå› ï¼šæ‰“åŠ«ã€è‡ªæ€ã€æˆ–ä½ç½®å·²è¢«å ç”¨`);
                        console.log(`   AIå°†å°è¯•å…¶ä»–ä½ç½®...`);
                        // ç”±äºAIå·²ç»éªŒè¯è¿‡ä½ç½®ï¼Œç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™é‡Œ
                        // å¦‚æœåˆ°äº†è¿™é‡Œï¼Œè¯´æ˜æœ‰bugï¼Œä½†æˆ‘ä»¬ç»§ç»­è®©AIå°è¯•è½å­
                        return;
                    }
                } else {
                    console.log(`âš ï¸ AIæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆä½ç½®`);
                    console.log(`   å¯èƒ½æ£‹ç›˜å·²æ»¡æˆ–å…¨éƒ¨è¢«å°é”`);
                    this.ui.showMessage('AIæ— æ³•è½å­ï¼Œæ¸¸æˆç»“æŸ');
                    this.endGame();
                    return;
                }

                this.currentPlayer = BLACK;
                this.ui.updateStatus(this.board, this.currentPlayer);
                console.log(`========== AI å›åˆç»“æŸ ==========\n`);
            }

            // å¤„ç†æ‚”æ£‹
            handleUndo() {
                if (this.gamePhase !== 'playing') return;

                // æ’¤é”€ AI çš„è½å­
                if (this.board.undo()) {
                    // æ’¤é”€ç©å®¶çš„è½å­
                    if (this.board.undo()) {
                        this.currentPlayer = BLACK;
                        this.ui.renderBoard(this.board);
                        this.ui.updateStatus(this.board, this.currentPlayer);
                        this.ui.showMessage('æ‚”æ£‹æˆåŠŸ');
                    } else {
                        // æ¢å¤ AI çš„è½å­
                        this.board.placeStone(
                            this.board.history[this.board.history.length - 1].x,
                            this.board.history[this.board.history.length - 1].y,
                            WHITE
                        );
                        this.ui.showMessage('æ— æ³•æ‚”æ£‹');
                    }
                } else {
                    this.ui.showMessage('æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ­¥æ•°');
                }
            }

            // ç»“æŸæ¸¸æˆ
            endGame() {
                this.gamePhase = 'finished';

                const territory = this.board.countTerritory();
                const blackScore = territory.black + this.board.captures.black;
                const whiteScore = territory.white + this.board.captures.white + 6.5; // è´´ç›®

                const result = {
                    winner: blackScore > whiteScore ? BLACK : WHITE,
                    blackScore,
                    whiteScore,
                    captures: this.board.captures
                };

                this.ui.showGameOver(result);
            }

            // é‡æ–°å¼€å§‹
            restart() {
                this.board = new GoBoard(13);
                this.ai = new GoAI(WHITE, this.board, this.difficulty);
                this.currentPlayer = BLACK;
                this.gamePhase = 'playing';

                this.ui.initBoard();
                this.ui.renderBoard(this.board);
                this.ui.updateStatus(this.board, this.currentPlayer);
                this.ui.showMessage(`éš¾åº¦: ${this.getDifficultyName()}`);
            }

            // è¿”å›éš¾åº¦é€‰æ‹©
            backToDifficultySelect() {
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('difficulty-modal').classList.remove('hidden');
            }
        }

        // ==================== å…¨å±€æ¸¸æˆå®ä¾‹å’Œå¼€å§‹å‡½æ•° ====================
        let game = null;
        let eventListeners = [];

        function startGame(difficulty) {
            // éšè—éš¾åº¦é€‰æ‹©ç•Œé¢
            document.getElementById('difficulty-modal').classList.add('hidden');

            // æ˜¾ç¤ºæ¸¸æˆå®¹å™¨
            document.getElementById('game-container').style.display = 'block';

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            eventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            eventListeners = [];

            // åˆ›å»ºæ¸¸æˆå®ä¾‹
            game = new GameController(difficulty);
        }

        // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨çš„è¾…åŠ©å‡½æ•°
        function registerEventListener(element, event, handler) {
            // ç§»é™¤å·²å­˜åœ¨çš„ç›¸åŒç›‘å¬å™¨ï¼ˆå¦‚æœæœ‰ï¼‰
            eventListeners = eventListeners.filter(listener => {
                if (listener.element === element && listener.event === event) {
                    listener.element.removeEventListener(listener.event, listener.handler);
                    return false;
                }
                return true;
            });

            // æ·»åŠ æ–°ç›‘å¬å™¨
            element.addEventListener(event, handler);
            eventListeners.push({ element, event, handler });
        }

        // ==================== åˆå§‹åŒ–æ¸¸æˆ ====================
        // é¡µé¢åŠ è½½æ—¶ä¸è‡ªåŠ¨åˆå§‹åŒ–ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©éš¾åº¦
    </script>
</body>
</html>